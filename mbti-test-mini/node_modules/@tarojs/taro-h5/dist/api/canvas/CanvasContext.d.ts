import Taro from '@tarojs/api';
import { CanvasGradient } from "@tarojs/api";
interface IAction {
    func: (...arr: any[]) => void;
    args: any[];
}
declare class CanvasContext implements Taro.CanvasContext {
    __raw__: CanvasRenderingContext2D;
    actions: IAction[];
    constructor(canvas: any, ctx: any);
    set ctx(e: CanvasRenderingContext2D);
    get ctx(): CanvasRenderingContext2D;
    canvas: HTMLCanvasElement;
    protected emptyActions(): void;
    protected enqueueActions(func: IAction['func'], ...args: any[]): void;
    set fillStyle(e: string);
    get fillStyle(): string;
    set font(e: string);
    get font(): string;
    set globalAlpha(e: number);
    get globalAlpha(): number;
    set globalCompositeOperation(e: GlobalCompositeOperation);
    get globalCompositeOperation(): GlobalCompositeOperation;
    set lineCap(e: CanvasLineCap);
    get lineCap(): CanvasLineCap;
    set lineDashOffset(e: number);
    get lineDashOffset(): number;
    set lineJoin(e: CanvasLineJoin);
    get lineJoin(): CanvasLineJoin;
    set lineWidth(e: number);
    get lineWidth(): number;
    set miterLimit(e: number);
    get miterLimit(): number;
    set shadowBlur(e: number);
    get shadowBlur(): number;
    set shadowColor(e: string);
    get shadowColor(): string;
    set shadowOffsetX(e: number);
    get shadowOffsetX(): number;
    set shadowOffsetY(e: number);
    get shadowOffsetY(): number;
    set strokeStyle(e: string);
    get strokeStyle(): string;
    /** 小程序文档中不包括 ↓↓↓ */
    set textAlign(e: CanvasTextAlign);
    get textAlign(): CanvasTextAlign;
    set textBaseline(e: CanvasTextBaseline);
    get textBaseline(): CanvasTextBaseline;
    set direction(e: CanvasDirection);
    get direction(): CanvasDirection;
    set imageSmoothingEnabled(e: boolean);
    get imageSmoothingEnabled(): boolean;
    set imageSmoothingQuality(e: ImageSmoothingQuality);
    get imageSmoothingQuality(): ImageSmoothingQuality;
    set filter(e: string);
    get filter(): string;
    /** 小程序文档中不包括 ↑↑↑ */
    /** 小程序文档中不包括 ↑↑↑ */
    arc(...args: any[]): void;
    arcTo(...args: any[]): void;
    beginPath(...args: any[]): void;
    bezierCurveTo(...args: any[]): void;
    clearRect(...args: any[]): void;
    clip(...args: any[]): void;
    closePath(...args: any[]): void;
    createPattern(imageResource: string, repetition: keyof Taro.CanvasContext.Repetition): CanvasPattern | null | Promise<CanvasPattern | null>;
    /**
     * 将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中。
     * @todo 每次 draw 都会读取 width 和 height
     */
    /**
     * 将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中。
     * @todo 每次 draw 都会读取 width 和 height
     */
    draw(reserve?: boolean, callback?: (...args: any[]) => any): Promise<void>;
    drawImage(imageResource: string, ...extra: any[]): void;
    fill(...args: any[]): void;
    fillRect(...args: any[]): void;
    fillText(...args: any[]): void;
    lineTo(...args: any[]): void;
    moveTo(...args: any[]): void;
    quadraticCurveTo(...args: any[]): void;
    rect(...args: any[]): void;
    // @ts-ignore
    reset(): any;
    restore(): void;
    rotate(...args: any[]): void;
    save(): void;
    scale(...args: any[]): void;
    setFillStyle(color: string | CanvasGradient): void;
    setFontSize(fontSize: number): void;
    setGlobalAlpha(alpha: number): void;
    setLineCap(lineCap: keyof Taro.CanvasContext.LineCap): void;
    setLineDash(pattern: number[], offset: number): void;
    setLineJoin(lineJoin: keyof Taro.CanvasContext.LineJoin): void;
    setLineWidth(lineWidth: number): void;
    setMiterLimit(miterLimit: number): void;
    setShadow(offsetX: number, offsetY: number, blur: number, color: string): void;
    setStrokeStyle(color: string | CanvasGradient): void;
    setTextAlign(align: keyof Taro.CanvasContext.Align): void;
    setTextBaseline(textBaseline: keyof Taro.CanvasContext.TextBaseline): void;
    setTransform(...args: any[]): void;
    stroke(...args: any[]): void;
    strokeRect(...args: any[]): void;
    strokeText(...args: any[]): void;
    transform(...args: any[]): void;
    translate(...args: any[]): void;
    measureText(text: string): TextMetrics;
    createCircularGradient(x: number, y: number, r: number): CanvasGradient;
    createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;
}
export { CanvasContext };
