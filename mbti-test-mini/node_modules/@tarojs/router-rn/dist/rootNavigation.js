// RootNavigation.js
import { StackActions } from '@react-navigation/native';
import { camelCase } from 'lodash';
import * as React from 'react';
import { getTabBarPages, handleUrl, setTabInitRoute, updateCurrentJumpUrl, updateJumpAnimate } from './utils/index';
let routeEvtChannel;
export const navigationRef = React.createRef();
export function navigateTo(option) {
    return navigate(option, 'navigateTo');
}
export function redirectTo(option) {
    return navigate(option, 'redirectTo');
}
export function navigateBack(option = {}) {
    return navigate(option, 'navigateBack');
}
export function switchTab(option) {
    return navigate(option, 'switchTab');
}
export function reLaunch(option) {
    return navigate(option, 'reLaunch');
}
export function navigate(option, method) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const { success, complete, fail } = option;
    let errMsg;
    let routeParam;
    const path = option.url;
    if (path) {
        routeParam = handleUrl(path);
        updateCurrentJumpUrl(path);
    }
    updateJumpAnimate(true);
    try {
        if (method === 'navigateTo') {
            (_a = navigationRef.current) === null || _a === void 0 ? void 0 : _a.dispatch(StackActions.push(routeParam.pageName, routeParam.params));
        }
        else if (method === 'redirectTo') {
            updateJumpAnimate(false);
            (_b = navigationRef.current) === null || _b === void 0 ? void 0 : _b.dispatch(StackActions.replace(routeParam.pageName, routeParam.params));
        }
        else if (method === 'switchTab' || (method === 'reLaunch' && isTabPage(path))) {
            const states = (_c = navigationRef.current) === null || _c === void 0 ? void 0 : _c.getRootState();
            if ((states === null || states === void 0 ? void 0 : states.routes[0].name) !== 'tabNav') {
                states && (states === null || states === void 0 ? void 0 : states.routes.length) > 1 && ((_d = navigationRef.current) === null || _d === void 0 ? void 0 : _d.dispatch(StackActions.popToTop()));
                (_e = navigationRef.current) === null || _e === void 0 ? void 0 : _e.dispatch(StackActions.replace('tabNav'));
                setTabInitRoute(routeParam.pageName);
            }
            else {
                (_f = navigationRef.current) === null || _f === void 0 ? void 0 : _f.navigate(routeParam.pageName, routeParam.params);
            }
        }
        else if (method === 'navigateBack') {
            const number = option.delta ? option.delta : 1;
            const states = (_g = navigationRef.current) === null || _g === void 0 ? void 0 : _g.getRootState();
            if ((states === null || states === void 0 ? void 0 : states.index) === 0) {
                errMsg = 'navigateBack:fail cannot navigate back at first page.';
            }
            else {
                const index = number && ((states && states.index < number) ? states === null || states === void 0 ? void 0 : states.index : number);
                (_h = navigationRef.current) === null || _h === void 0 ? void 0 : _h.dispatch(StackActions.pop(index));
            }
        }
        else if (method === 'reLaunch') {
            if (isTabPage()) {
                // tabbar to stack page
                (_j = navigationRef.current) === null || _j === void 0 ? void 0 : _j.dispatch(StackActions.replace(routeParam.pageName, routeParam.params));
            }
            else {
                // stack to stack page
                const states = (_k = navigationRef.current) === null || _k === void 0 ? void 0 : _k.getRootState();
                if ((states === null || states === void 0 ? void 0 : states.index) !== 0) {
                    (_l = navigationRef.current) === null || _l === void 0 ? void 0 : _l.dispatch(StackActions.popToTop());
                }
                (_m = navigationRef.current) === null || _m === void 0 ? void 0 : _m.dispatch(StackActions.replace(routeParam.pageName, routeParam.params));
            }
        }
    }
    catch (error) {
        errMsg = error;
    }
    return new Promise((resolve, reject) => {
        if (errMsg) {
            fail && fail({ errMsg });
            complete && complete({ errMsg });
            reject(new Error(errMsg));
        }
        else {
            const msg = {
                errMsg: `${method}:ok`
            };
            if (method === 'navigateTo') {
                routeEvtChannel.addEvents(option.events);
                msg.eventChannel = routeEvtChannel;
            }
            success && success(msg);
            complete && complete(msg);
            resolve(msg);
        }
    });
}
export function isTabPage(path = '') {
    var _a;
    const tabPages = getTabBarPages();
    let pageName = '';
    if (path) {
        pageName = camelCase((path.startsWith('/') ? path : `/${path}`).split('?')[0]);
    }
    else {
        const route = ((_a = navigationRef.current) === null || _a === void 0 ? void 0 : _a.getCurrentRoute()) || {};
        pageName = (route === null || route === void 0 ? void 0 : route.name) || '';
    }
    return tabPages.indexOf(pageName) !== -1;
}
export function getCurrentRoute() {
    var _a;
    const routeState = (_a = navigationRef.current) === null || _a === void 0 ? void 0 : _a.getRootState();
    const routes = routeState === null || routeState === void 0 ? void 0 : routeState.routes;
    const routeKeys = [];
    if (routes) {
        routes.forEach(item => {
            var _a, _b, _c, _d;
            if (item.name === 'tabNav') {
                const index = (_b = (_a = item.state) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : 0;
                const tabRoutes = (_d = (_c = item.state) === null || _c === void 0 ? void 0 : _c.routes) !== null && _d !== void 0 ? _d : [];
                (tabRoutes === null || tabRoutes === void 0 ? void 0 : tabRoutes[index]) && routeKeys.push(tabRoutes[index].key);
            }
            else {
                routeKeys.push(item.key);
            }
        });
    }
    return routeKeys;
}
export const getRouteEventChannel = (routeChannel) => {
    routeEvtChannel = routeChannel;
};
//# sourceMappingURL=rootNavigation.js.map