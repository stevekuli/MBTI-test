import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { CardStyleInterpolators, createStackNavigator } from '@react-navigation/stack';
import { camelCase } from 'lodash';
import React from 'react';
import { navigationRef } from './rootNavigation';
import { getCurrentJumpUrl, getTabInitRoute, getTabItemConfig, getTabVisible, handleUrl, hasJumpAnimate, setTabConfig } from './utils/index';
import BackButton from './view/BackButton';
import HeadTitle from './view/HeadTitle';
import CustomTabBar from './view/TabBar';
export function createRouter(config, options) {
    var _a, _b;
    if ((_b = (_a = config === null || config === void 0 ? void 0 : config.tabBar) === null || _a === void 0 ? void 0 : _a.list) === null || _b === void 0 ? void 0 : _b.length) {
        return createTabNavigate(config, options);
    }
    else {
        return createStackNavigate(config, options);
    }
}
// åˆå§‹åŒ–è·¯ç”±ç›¸å…³ï¼Œå…¥å£ç»„ä»¶ï¼ŒonLaunchï¼ŒonShow
export function getInitOptions(config) {
    var _a;
    const initRouteName = getInitRouteName(config);
    const initParams = getInitParams(config, initRouteName);
    const initPath = (_a = config.pages.find(p => p.name === initRouteName)) === null || _a === void 0 ? void 0 : _a.pagePath;
    return {
        path: initPath,
        query: initParams,
    };
}
function getTabNames(config) {
    let tabNames = [];
    const tabBar = config === null || config === void 0 ? void 0 : config.tabBar;
    if (!tabBar)
        return tabNames;
    tabNames = tabBar.list.map(item => {
        const pagePath = item.pagePath.startsWith('/') ? item.pagePath : `/${item.pagePath}`;
        return camelCase(pagePath);
    });
    return tabNames;
}
function getPageList(config) {
    // pageList åŽ»é™¤tabbarçš„é¡µé¢
    const tabBar = config.tabBar;
    const pageList = config.pages;
    if (!tabBar)
        return pageList;
    const tabNames = getTabNames(config);
    return pageList.filter(item => tabNames.indexOf(item.name) === -1);
}
function getTabItemOptions(item, index) {
    return {
        tabBarLabel: getTabItemConfig(index, 'tabBarLabel') || item.text,
        tabBarBadge: getTabItemConfig(index, 'tabBarBadge'),
        tabBarVisible: getTabVisible(),
        tabBarTestID: `tabbar-${index}`
    };
}
function getHeaderView(title, color, props) {
    return React.createElement(HeadTitle, { label: title, color: color, headerProps: props });
}
// screené…ç½®çš„å†…å®¹
function getStackOptions(config) {
    const windowOptions = config.window || {};
    const title = '';
    const headColor = windowOptions.navigationBarTextStyle || 'white';
    const bgColor = windowOptions.navigationBarBackgroundColor || '#000000';
    const headerTitleAlign = 'center';
    const defaultOptions = {
        title: title,
        headerShown: windowOptions.navigationStyle !== 'custom',
        headerTitle: (props) => getHeaderView(title, headColor, props),
        headerStyle: {
            backgroundColor: bgColor,
            shadowOffset: { width: 0, height: 0 },
            borderWidth: 0,
            elevation: 0,
            shadowOpacity: 1,
            borderBottomWidth: 0
        },
        headerTintColor: headColor,
        cardStyleInterpolator: CardStyleInterpolators.forHorizontalIOS,
        cardStyle: { elevation: 1 },
        headerBackTitleVisible: false,
        headerTitleAlign,
        // eslint-disable-next-line react/display-name
        headerBackImage: ({ tintColor }) => {
            return React.createElement(BackButton, { tintColor: tintColor });
        }
    };
    const rnConfig = config.rnConfig || {};
    const screenOptions = (rnConfig === null || rnConfig === void 0 ? void 0 : rnConfig.screenOptions) || {};
    return Object.assign({}, defaultOptions, screenOptions);
}
function getTabItem(config, tabName) {
    const tabBar = config.tabBar;
    const pageList = config.pages;
    if (!tabBar)
        return pageList;
    let tabItem = {
        name: '',
        component: {},
        pagePath: ''
    };
    pageList.forEach(item => {
        if (item.name === tabName) {
            tabItem = item;
        }
    });
    return tabItem;
}
let initRoute;
function getInitRouteName(config) {
    var _a;
    if (initRoute)
        return initRoute;
    const initPath = config.initPath || '';
    const rn = config.rnConfig || {};
    if (initPath) {
        initRoute = handleUrl(initPath).pageName;
    }
    else if (rn === null || rn === void 0 ? void 0 : rn.initialRouteName) {
        initRoute = camelCase(rn.initialRouteName);
    }
    else if (config.entryPagePath) {
        const entryPagePath = config.entryPagePath.startsWith('/') ? config.entryPagePath : `/${config.entryPagePath}`;
        initRoute = (_a = config.pages.find(p => p.pagePath === entryPagePath)) === null || _a === void 0 ? void 0 : _a.name;
    }
    else {
        initRoute = config.pages[0].name;
    }
    return initRoute;
}
function getInitTabRoute(config) {
    const pageList = config.pages;
    const tabNames = getTabNames(config);
    const initPath = config.initPath || '';
    let initTabName = '';
    if (initPath) { // ä¼˜å…ˆåŽŸç”Ÿä¼ å…¥çš„è·¯ç”±
        const route = handleUrl(initPath).pageName;
        for (let i = 0; i < tabNames.length; i++) {
            if (route === tabNames[i]) {
                initTabName = tabNames[i];
                break;
            }
        }
    }
    if (!initTabName) {
        for (let i = 0; i < pageList.length; i++) {
            const item = pageList[i];
            if (tabNames.indexOf(item.name) !== -1) {
                initTabName = item.name;
                break;
            }
        }
    }
    return initTabName;
}
function getInitParams(config, pageName) {
    let params = {};
    const initRouteName = getInitRouteName(config);
    if (initRouteName === pageName) {
        const initPath = config.initPath || '';
        params = handleUrl(initPath).params;
        params = Object.assign({}, params, config.initParams);
    }
    return params;
}
function createTabStack(config, parentProps, screenOptions) {
    var _a;
    const Tab = createBottomTabNavigator();
    const tabBar = config.tabBar;
    const rnConfig = config.rnConfig;
    const tabList = [];
    const tabOptions = (rnConfig === null || rnConfig === void 0 ? void 0 : rnConfig.tabOptions) || {};
    tabBar === null || tabBar === void 0 ? void 0 : tabBar.list.forEach((item, index) => {
        var _a;
        const defaultOptions = Object.assign({}, { tabBarVisible: ((_a = config.tabBar) === null || _a === void 0 ? void 0 : _a.custom) ? false : getTabVisible() }, getTabItemOptions(item, index));
        const tabItemOptions = Object.assign({}, defaultOptions, tabOptions, { headerShown: false, title: item.text });
        setTabConfig('tabBarVisible', tabItemOptions.tabBarVisible);
        const path = item.pagePath.startsWith('/') ? item.pagePath : `/${item.pagePath}`;
        const tabName = camelCase(path);
        const tabPage = getTabItem(config, tabName);
        const initParams = getInitParams(config, tabName);
        tabList.push(React.createElement(Tab.Screen, Object.assign({ key: `tab${tabName}`, name: tabPage.name, options: tabItemOptions, component: tabPage.component, initialParams: initParams }, parentProps)));
    });
    const borderColorMap = {
        black: '#000000',
        white: '#ffffff'
    };
    // å…è®¸ä¼ å…¥è‰²å€¼ã€blackã€whiteã€é»˜è®¤ #000000
    const borderTopColor = (tabBar === null || tabBar === void 0 ? void 0 : tabBar.borderStyle) ? (borderColorMap[tabBar === null || tabBar === void 0 ? void 0 : tabBar.borderStyle] || (tabBar === null || tabBar === void 0 ? void 0 : tabBar.borderStyle)) : '#000000';
    const userTabBarOptions = (rnConfig === null || rnConfig === void 0 ? void 0 : rnConfig.tabBarOptions) || {};
    // tabbarOptions
    const tabBarOptions = Object.assign({
        backBehavior: 'none',
        activeTintColor: (tabBar === null || tabBar === void 0 ? void 0 : tabBar.selectedColor) || '#3cc51f',
        inactiveTintColor: (tabBar === null || tabBar === void 0 ? void 0 : tabBar.color) || '#7A7E83',
        activeBackgroundColor: (tabBar === null || tabBar === void 0 ? void 0 : tabBar.backgroundColor) || '#ffffff',
        inactiveBackgroundColor: (tabBar === null || tabBar === void 0 ? void 0 : tabBar.backgroundColor) || '#ffffff',
        style: {
            backgroundColor: tabBar === null || tabBar === void 0 ? void 0 : tabBar.backgroundColor,
            borderTopColor
        }
    }, userTabBarOptions);
    const tabNames = getTabNames(config);
    const tabProps = ((_a = config.rnConfig) === null || _a === void 0 ? void 0 : _a.tabProps) || {};
    const tabInitRouteName = getTabInitRoute() || getInitTabRoute(config) || tabNames[0];
    return React.createElement(Tab.Navigator, Object.assign({}, tabProps, { tabBar: (props) => createTabBar(props, tabOptions, tabBarOptions), initialRouteName: tabInitRouteName, screenOptions: screenOptions }), tabList);
}
function createTabBar(props, tabOptions, tabBarOptions) {
    return React.createElement(CustomTabBar, Object.assign({}, props, { tabOptions: tabOptions }, tabBarOptions));
}
function getLinkingConfig(config) {
    var _a, _b;
    const prefixes = ((_a = config === null || config === void 0 ? void 0 : config.rnConfig) === null || _a === void 0 ? void 0 : _a.linking) || config.linkPrefix || [];
    const screens = {};
    const pageList = getPageList(config);
    pageList.forEach(item => {
        const path = item.pagePath.startsWith('/') ? item.pagePath.substr(1) : item.pagePath;
        screens[`${item.name}`] = path;
    });
    let tabScreen = {};
    if (config.tabBar) {
        const tabs = {};
        const tabBarList = ((_b = config.tabBar) === null || _b === void 0 ? void 0 : _b.list) || [];
        tabBarList.forEach((item) => {
            const tabPath = item.pagePath.startsWith('/') ? item.pagePath : `/${item.pagePath}`;
            const tabName = camelCase(tabPath);
            tabs[`${tabName}`] = tabPath;
        });
        tabScreen = {
            tabNav: {
                path: '',
                screens: tabs
            }
        };
    }
    return {
        prefixes: prefixes,
        config: {
            screens: Object.assign(Object.assign({}, tabScreen), screens)
        }
    };
}
function defaultOnUnhandledAction(action) {
    var _a;
    // @ts-ignore
    if (process.env.NODE_ENV === 'production') {
        return;
    }
    const payload = action.payload;
    let message = `The action '${action.type}'${payload ? ` with payload ${JSON.stringify(action.payload)}` : ''} was not handled by any navigator.`;
    switch (action.type) {
        case 'NAVIGATE':
        case 'PUSH':
        case 'REPLACE':
        case 'JUMP_TO':
            if (payload === null || payload === void 0 ? void 0 : payload.name) {
                const pageName = (_a = getCurrentJumpUrl()) !== null && _a !== void 0 ? _a : payload === null || payload === void 0 ? void 0 : payload.name;
                message += `\n\nDo you have a screen '${pageName}'?\n\nIf you're trying to navigate to a screen in a nested navigator, see https://reactnavigation.org/docs/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator.`;
            }
            else {
                message += `\n\nYou need to pass the name of the screen to navigate to.\n\nSee https://reactnavigation.org/docs/navigation-actions for usage.`;
            }
            break;
        case 'GO_BACK':
        case 'POP':
        case 'POP_TO_TOP':
            message += `\n\nIs there any screen to go back to?`;
            break;
        case 'OPEN_DRAWER':
        case 'CLOSE_DRAWER':
        case 'TOGGLE_DRAWER':
            message += `\n\nIs your screen inside a Drawer navigator?`;
            break;
    }
    message += `\n\nThis is a development-only warning and won't be shown in production.`;
    console.error(message);
}
function handlePageNotFound(action, options) {
    var _a, _b, _c;
    const routeObj = (_a = action === null || action === void 0 ? void 0 : action.payload) !== null && _a !== void 0 ? _a : {};
    if (routeObj === null || routeObj === void 0 ? void 0 : routeObj.name) {
        (options === null || options === void 0 ? void 0 : options.onUnhandledAction) && (options === null || options === void 0 ? void 0 : options.onUnhandledAction({
            path: (_b = getCurrentJumpUrl()) !== null && _b !== void 0 ? _b : routeObj === null || routeObj === void 0 ? void 0 : routeObj.name,
            query: (_c = routeObj === null || routeObj === void 0 ? void 0 : routeObj.params) !== null && _c !== void 0 ? _c : {}
        }));
    }
    // ç›‘å¬äº†onUnhandledActionï¼Œå¯¼èˆªé»˜è®¤æ‰“å°é”™è¯¯å°±ä¸æ‰§è¡Œäº†, æŠŠæºç ä¸­é»˜è®¤æ‰“å°åŠ ä¸€ä¸‹ðŸ˜­
    defaultOnUnhandledAction(action);
}
function createTabNavigate(config, options) {
    var _a, _b;
    const Stack = ((_a = config.rnConfig) === null || _a === void 0 ? void 0 : _a.useNativeStack) ? createNativeStackNavigator() : createStackNavigator();
    const pageList = getPageList(config);
    const linking = getLinkingConfig(config);
    const stackProps = (_b = config.rnConfig) === null || _b === void 0 ? void 0 : _b.stackProps;
    const screenOptions = getStackOptions(config);
    return React.createElement(NavigationContainer, { ref: navigationRef, linking: linking, onUnhandledAction: (action) => handlePageNotFound(action, options) },
        React.createElement(Stack.Navigator, Object.assign({ detachInactiveScreens: false }, stackProps, { 
            // @ts-ignore
            screenOptions: () => (Object.assign(Object.assign({}, screenOptions), { animation: hasJumpAnimate() ? 'default' : 'none', animationEnabled: !!hasJumpAnimate() })), initialRouteName: getInitRouteName(config) }),
            React.createElement(Stack.Screen, { name: 'tabNav', key: 'tabScreen', options: {
                    headerShown: false
                } }, (props) => createTabStack(config, props, screenOptions)),
            pageList.map(item => {
                const initParams = getInitParams(config, item.name);
                return React.createElement(Stack.Screen, { key: item.name, name: item.name, component: item.component, initialParams: initParams });
            })));
}
function createStackNavigate(config, options) {
    var _a, _b;
    const Stack = ((_a = config.rnConfig) === null || _a === void 0 ? void 0 : _a.useNativeStack) ? createNativeStackNavigator() : createStackNavigator();
    const pageList = getPageList(config);
    if (pageList.length <= 0)
        return null;
    const linking = getLinkingConfig(config);
    const stackProps = (_b = config.rnConfig) === null || _b === void 0 ? void 0 : _b.stackProps;
    const screenOptions = getStackOptions(config);
    return React.createElement(NavigationContainer, { ref: navigationRef, linking: linking, onUnhandledAction: (action) => handlePageNotFound(action, options) },
        React.createElement(Stack.Navigator, Object.assign({ detachInactiveScreens: false }, stackProps, { 
            // @ts-ignore
            screenOptions: () => (Object.assign(Object.assign({}, screenOptions), { animation: hasJumpAnimate() ? 'default' : 'none', animationEnabled: !!hasJumpAnimate() })), initialRouteName: getInitRouteName(config) }), pageList.map(item => {
            const initParams = getInitParams(config, item.name);
            return React.createElement(Stack.Screen, { key: item.name, name: item.name, component: item.component, initialParams: initParams });
        })));
}
//# sourceMappingURL=router.js.map