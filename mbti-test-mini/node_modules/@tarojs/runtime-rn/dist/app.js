import { Provider as TCNProvider } from '@tarojs/components-rn';
import { EventChannel } from '@tarojs/shared';
import React, { Component, createElement, createRef, forwardRef } from 'react';
import { RootSiblingParent } from 'react-native-root-siblings';
import { Current } from './current';
import { getPageInstance } from './page';
import { createRouter, getInitOptions, getRouteEventChannel } from './router';
import { HOOKS_APP_ID, isFunction } from './utils';
export function isClassComponent(component) {
    var _a;
    return (isFunction(component === null || component === void 0 ? void 0 : component.render) || !!((_a = component.prototype) === null || _a === void 0 ? void 0 : _a.isReactComponent) || component.prototype instanceof Component);
}
export function createReactNativeApp(AppEntry, config, FirstPage) {
    var _a, _b, _c;
    const singleMode = (_c = (_b = (_a = config === null || config === void 0 ? void 0 : config.appConfig) === null || _a === void 0 ? void 0 : _a.rn) === null || _b === void 0 ? void 0 : _b.singleMode) !== null && _c !== void 0 ? _c : false;
    const needNavigate = config.pageList.length !== 1 || !singleMode;
    if (needNavigate) {
        getRouteEventChannel(EventChannel.routeChannel);
    }
    const routerConfig = {
        tabBar: config.appConfig.tabBar,
        pages: config.pageList,
        entryPagePath: config.appConfig.entryPagePath,
        window: config.appConfig.window,
        linkPrefix: config.appConfig.linkPrefix || [],
        rnConfig: config.appConfig.rn || {}
    };
    const appRef = createRef();
    const isReactComponent = isClassComponent(AppEntry);
    let entryComponent = AppEntry;
    if (!isReactComponent) {
        // eslint-disable-next-line react/display-name
        entryComponent = forwardRef((props, ref) => {
            return React.createElement(AppEntry, Object.assign({ forwardRef: ref }, props));
        });
    }
    const NewAppComponent = (AppComponent) => {
        return class Entry extends Component {
            constructor(props) {
                super(props);
                const { initPath = '', initParams = {} } = this.props;
                routerConfig.initPath = initPath;
                routerConfig.initParams = initParams;
            }
            componentDidMount() {
                let options = {};
                if (needNavigate) {
                    options = getInitOptions(routerConfig);
                }
                triggerAppLifecycle('onLaunch', options);
                triggerAppLifecycle('componentDidShow', options);
            }
            // 导航onUnhandledAction
            onUnhandledAction(options) {
                triggerAppLifecycle('onPageNotFound', options);
            }
            render() {
                const props = null;
                const appProps = Object.assign(Object.assign({}, props), this.props);
                let routerOptions = {};
                if (needNavigate) {
                    routerOptions = {
                        onUnhandledAction: this.onUnhandledAction
                    };
                }
                const child = needNavigate
                    ? createRouter(routerConfig, routerOptions)
                    : createElement(FirstPage, Object.assign({}, this.props), []);
                return createElement(RootSiblingParent, null, createElement(TCNProvider, Object.assign({}, this.props), createElement(AppComponent, Object.assign(Object.assign({}, appProps), { ref: appRef }), child)));
            }
        };
    };
    const App = NewAppComponent(entryComponent);
    // 与小程序端实例保持一致
    const appInst = Object.create({}, {
        config: {
            writable: true,
            enumerable: true,
            configurable: true,
            value: config.appConfig
        },
        onLaunch: {
            enumerable: true,
            writable: true,
            value(options) {
                triggerAppLifecycle('onLaunch', options);
            }
        },
        onShow: {
            enumerable: true,
            writable: true,
            value(options) {
                triggerAppLifecycle('componentDidShow', options);
            }
        },
        onHide: {
            enumerable: true,
            writable: true,
            value(options) {
                triggerAppLifecycle('componentDidHide', options);
            }
        },
        onPageNotFound: {
            enumerable: true,
            writable: true,
            value(options) {
                triggerAppLifecycle('onPageNotFound', options);
            }
        }
    });
    function triggerAppLifecycle(lifecycle, ...args) {
        try {
            const app = appRef.current;
            if (isReactComponent) {
                (app === null || app === void 0 ? void 0 : app[lifecycle]) && (app === null || app === void 0 ? void 0 : app[lifecycle](...args));
            }
            else {
                const instance = getPageInstance(HOOKS_APP_ID);
                if (instance) {
                    const func = instance[lifecycle];
                    if (Array.isArray(func)) {
                        func.forEach((cb) => cb.apply(app, args));
                    }
                }
            }
        }
        catch (err) {
            throw new Error(err);
        }
    }
    Current.app = appInst;
    return App;
}
export function getApp() {
    return Current.app;
}
//# sourceMappingURL=app.js.map