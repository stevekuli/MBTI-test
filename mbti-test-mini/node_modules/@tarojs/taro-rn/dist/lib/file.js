var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as FileSystem from 'expo-file-system';
import { Platform } from 'react-native';
import { shouldBeObject, successHandler, errorHandler } from '../utils';
let timer;
const _fetch = (requestPromise, timeout) => {
    let timeoutAction;
    const timerPromise = new Promise((_resolve, reject) => {
        timeoutAction = () => {
            reject(new Error('网络请求超时'));
        };
    });
    timer = setTimeout(() => {
        timeoutAction();
        !!timer && clearTimeout(timer);
    }, timeout);
    return Promise.race([requestPromise, timerPromise]);
};
const isAndroid = Platform.OS === 'android';
const createFormData = (filePath, body, name) => {
    const data = new FormData();
    const uri = isAndroid ? filePath : filePath.replace('file://', '');
    const fileObj = { uri: uri, type: 'application/octet-stream', name: 'file' };
    Object.keys(body).forEach(key => {
        data.append(key, body[key]);
    });
    // @ts-ignore
    data.append(name, fileObj);
    return data;
};
/**
 * 将本地资源上传到服务器。客户端发起一个 HTTPS POST 请求，其中 content-type 为 multipart/form-data。
 * @param {object} opts
 * @param {string} opts.url - 开发者服务器地址
 * @param {number} opts.timeout - 超时时间，单位为毫秒
 * @param {string} opts.filePath - 要上传文件资源的路径
 * @param {string} opts.name - 文件对应的 key，开发者在服务端可以通过这个 key 获取文件的二进制内容
 * @param {object} [opts.header] - HTTP 请求 Header，Header 中不能设置 Referer
 * @param {object} [opts.formData] - HTTP 请求中其他额外的 form data
 * @return UploadTask - 一个可以监听上传进度进度变化的事件和取消上传的对象
 */
function uploadFile(opts) {
    const { url, timeout = 2000, filePath, name, header, formData = {}, success, fail, complete } = opts;
    const execFetch = fetch(url, {
        method: 'POST',
        body: createFormData(filePath, formData, name),
        headers: header
    });
    return _fetch(execFetch, timeout).then((res) => {
        return successHandler(success, complete)(res);
    }).catch(e => {
        const errMsg = `uploadFile fail: ${e}`;
        return errorHandler(fail, complete)({ errMsg });
    });
}
/**
 * 下载文件资源到本地。客户端直接发起一个 HTTPS GET 请求，返回文件的本地临时路径，单次下载允许的最大文件为 50MB。
 * @param opts
 * @param {string} opts.url - 下载资源的 url
 * @param {Object} [opts.header] - HTTP 请求的 Header，Header 中不能设置 Referer
 * @param {string} [opts.filePath] - 指定文件下载后存储的路径
 * @returns {*}
 */
function downloadFile(opts) {
    const { url, header, filePath, success, fail, complete } = opts;
    let downloadResumable;
    const p = new Promise((resolve, reject) => {
        let fileName = url.split('/');
        fileName = fileName[fileName.length - 1];
        const downloadFileCallback = (res) => {
            const { totalBytesWritten, totalBytesExpectedToWrite } = res;
            let progress = totalBytesWritten / totalBytesExpectedToWrite * 100;
            progress = Number(progress.toFixed(2));
            p.onProgressUpdateCb && p.onProgressUpdateCb({
                progress,
                totalBytesWritten,
                totalBytesExpectedToWrite
            });
        };
        downloadResumable = FileSystem.createDownloadResumable(url, filePath || `${FileSystem.documentDirectory}${fileName}`, {
            headers: header
        }, downloadFileCallback);
        downloadResumable.downloadAsync().then((resp) => {
            const { uri, status } = resp;
            const res = {
                tempFilePath: uri,
                statusCode: status
            };
            filePath && (res.filePath = filePath);
            success === null || success === void 0 ? void 0 : success(res);
            complete === null || complete === void 0 ? void 0 : complete(res);
            resolve(res);
        }).catch((err) => {
            const res = {
                errMsg: 'download file fail',
                err
            };
            fail === null || fail === void 0 ? void 0 : fail(res);
            complete === null || complete === void 0 ? void 0 : complete(res);
            reject(res);
        });
    });
    p.onProgressUpdate = (cb) => {
        if (cb) {
            p.onProgressUpdateCb = cb;
        }
    };
    p.abort = (cb) => {
        downloadResumable.pauseAsync();
        cb && cb();
    };
    return p;
}
/**
 * 保存文件到本地。注意：saveFile 会把临时文件移动，因此调用成功后传入的 tempFilePath 将不可用
 * @param opts
 * @param {string} opts.tempFilePath 需要保存的文件的临时路径
 */
function saveFile(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = { errMsg: 'saveFile:ok' };
        const isObject = shouldBeObject(opts);
        if (!isObject.res) {
            res.errMsg = `saveFile${isObject.msg}`;
            return Promise.reject(res);
        }
        const { tempFilePath, filePath, success, fail, complete } = opts || {};
        const fileName = tempFilePath.substring(tempFilePath.lastIndexOf('/') + 1);
        const destPath = filePath || FileSystem.documentDirectory;
        const savedFilePath = destPath + fileName;
        try {
            const props = yield FileSystem.getInfoAsync(destPath);
            if (!props.exists) {
                yield FileSystem.makeDirectoryAsync(destPath, { intermediates: true });
            }
            if (filePath) {
                // const toPath = !isAndroid ? destPath : savedFilePath
                yield FileSystem.moveAsync({ from: tempFilePath, to: savedFilePath });
            }
            res.savedFilePath = savedFilePath;
            success === null || success === void 0 ? void 0 : success(res);
            complete === null || complete === void 0 ? void 0 : complete(res);
            return res;
        }
        catch (e) {
            res.errMsg = `saveFile:fail. ${e.message}`;
            fail === null || fail === void 0 ? void 0 : fail(res);
            complete === null || complete === void 0 ? void 0 : complete(res);
            throw res;
        }
    });
}
/**
 * 删除本地缓存文件
 * @param opts
 * @param {string} opts.filePath 需要删除的文件路径
 */
function removeSavedFile(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        let res = { errMsg: 'removeSavedFile:ok' };
        const isObject = shouldBeObject(opts);
        if (!isObject.res) {
            res.errMsg = `removeSavedFile${isObject.msg}`;
            console.error(res);
            return Promise.reject(res);
        }
        const { filePath, success, fail, complete } = opts || {};
        try {
            const obj = yield FileSystem.deleteAsync(filePath);
            res = Object.assign(Object.assign({}, res), obj);
            return successHandler(success, complete)(res);
        }
        catch (e) {
            res.errMsg = `removeSavedFile:fail. ${e.message}`;
            return errorHandler(fail, complete)(res);
        }
    });
}
/**
 * 获取该小程序下已保存的本地缓存文件列表
 * @param opts
 * @param {string} opts.filePath 文件路径
 */
function getSavedFileList(opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = { errMsg: 'getSavedFileList:ok' };
        const isObject = shouldBeObject(opts);
        if (!isObject.res) {
            res.errMsg = `getSavedFileList${isObject.msg}`;
            console.error(res);
            return Promise.reject(res);
        }
        const { success, fail, complete } = opts;
        const fileList = [];
        try {
            const fileNameList = yield FileSystem.readDirectoryAsync(FileSystem.documentDirectory);
            fileNameList.forEach((fileName) => __awaiter(this, void 0, void 0, function* () {
                const fileInfo = yield FileSystem.getInfoAsync(FileSystem.documentDirectory + fileName);
                if (fileInfo.isDirectory) {
                    fileList.push({
                        filePath: fileInfo.uri,
                        size: fileInfo.size,
                        createTime: fileInfo.modificationTime
                    });
                }
            }));
            res.fileList = fileList;
            success === null || success === void 0 ? void 0 : success(res);
            complete === null || complete === void 0 ? void 0 : complete(res);
            return res;
        }
        catch (e) {
            res.errMsg = `getSavedFileList:fail. ${e.message}`;
            fail === null || fail === void 0 ? void 0 : fail(res);
            complete === null || complete === void 0 ? void 0 : complete(res);
            throw res;
        }
    });
}
/**
 * 获取本地文件的文件信息。此接口只能用于获取已保存到本地的文件，若需要获取临时文件信息，请使用 wx.getFileInfo() 接口。
 * @param opts
 */
function getSavedFileInfo(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = { errMsg: 'getSavedFileInfo:ok' };
        const isObject = shouldBeObject(opts);
        if (!isObject.res) {
            res.errMsg = `getSavedFileInfo${isObject.msg}`;
            console.error(res);
            return Promise.reject(res);
        }
        const { filePath, success, fail, complete } = opts || {};
        try {
            const obj = yield FileSystem.getInfoAsync(filePath, { md5: true });
            if (!obj.exists) {
                throw new Error('filePath not exists');
            }
            res.size = obj.size;
            res.createTime = obj.modificationTime;
            success === null || success === void 0 ? void 0 : success(res);
            complete === null || complete === void 0 ? void 0 : complete(res);
            return res;
        }
        catch (e) {
            res.errMsg = `getSavedFileInfo:fail. ${e.message}`;
            fail === null || fail === void 0 ? void 0 : fail(res);
            complete === null || complete === void 0 ? void 0 : complete(res);
            throw res;
        }
    });
}
/**
 * 获取文件信息
 * @param opts
 * @param {string} opts.filePath -  本地文件路径
 * @param {string} [opts.digestAlgorithm] - 计算文件摘要的算法
 */
function getFileInfo(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = { errMsg: 'getFileInfo:ok' };
        const isObject = shouldBeObject(opts);
        if (!isObject.res) {
            res.errMsg = `getFileInfo${isObject.msg}`;
            console.error(res);
            return Promise.reject(res);
        }
        const { filePath, success, fail, complete } = opts || {};
        try {
            const obj = yield FileSystem.getInfoAsync(filePath, { md5: true });
            if (!obj.exists) {
                throw new Error('filePath not exists');
            }
            res.size = obj.size;
            res.md5 = obj.md5;
            success === null || success === void 0 ? void 0 : success(res);
            complete === null || complete === void 0 ? void 0 : complete(res);
            return res;
        }
        catch (e) {
            res.errMsg = `getFileInfo:fail. ${e.message}`;
            fail === null || fail === void 0 ? void 0 : fail(res);
            complete === null || complete === void 0 ? void 0 : complete(res);
            throw res;
        }
    });
}
/**
 * @todo
 * 获取全局唯一的文件管理器
 */
// function getFileSystemManager () {
//   console.log('not finished')
// }
/**
 * @todo
 * 新开页面打开文档
 * @param opts
 * @param opts.filePath 文件路径，可通过 downloadFile 获得
 * @param opts.fileType 文件类型，指定文件类型打开文件
 */
// function openDocument (opts = {}) {
//   console.log('not finished')
// }
export { downloadFile, uploadFile, saveFile, removeSavedFile, getSavedFileList, getSavedFileInfo, getFileInfo };
//# sourceMappingURL=file.js.map