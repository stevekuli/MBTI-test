"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.H5WebpackPlugin = void 0;
const helper_1 = require("@tarojs/helper");
const shared_1 = require("@tarojs/shared");
const html_webpack_plugin_1 = __importDefault(require("html-webpack-plugin"));
const path_1 = __importDefault(require("path"));
const H5Plugin_1 = __importDefault(require("../plugins/H5Plugin"));
const WebpackPlugin_1 = __importDefault(require("./WebpackPlugin"));
class H5WebpackPlugin {
    constructor(combination) {
        this.combination = combination;
    }
    getPlugins() {
        const plugins = {
            definePlugin: this.getDefinePlugin(),
            mainPlugin: this.getMainPlugin()
        };
        const template = path_1.default.join(this.combination.sourceDir, 'index.html');
        if (helper_1.fs.existsSync(template)) {
            const pages = this.pages || [];
            if (pages.length > 0) {
                // NOTE: multi router
                pages.forEach(page => {
                    plugins[page] = this.getHtmlWebpackPlugin(template, page);
                });
            }
            else {
                plugins.htmlWebpackPlugin = this.getHtmlWebpackPlugin(template);
            }
        }
        const miniCssExtractPlugin = this.getMiniCssExtractPlugin();
        if (miniCssExtractPlugin)
            plugins.miniCssExtractPlugin = miniCssExtractPlugin;
        const copyWebpackPlugin = this.getCopyWebpackPlugin();
        if (copyWebpackPlugin)
            plugins.copyWebpackPlugin = copyWebpackPlugin;
        return plugins;
    }
    getDefinePlugin() {
        const { env = {}, defineConstants = {}, buildAdapter = helper_1.PLATFORMS.H5, framework = 'react', useDeprecatedAdapterComponent = false } = this.combination.config;
        env.FRAMEWORK = JSON.stringify(framework);
        env.TARO_ENV = JSON.stringify(buildAdapter);
        env.TARO_PLATFORM = JSON.stringify(process.env.TARO_PLATFORM || shared_1.PLATFORM_TYPE.WEB);
        env.SUPPORT_TARO_POLYFILL = env.SUPPORT_TARO_POLYFILL || '"enabled"';
        env.SUPPORT_DINGTALK_NAVIGATE = env.SUPPORT_DINGTALK_NAVIGATE || '"disabled"';
        const envConstants = Object.keys(env).reduce((target, key) => {
            target[`process.env.${key}`] = env[key];
            return target;
        }, {});
        defineConstants.DEPRECATED_ADAPTER_COMPONENT = JSON.stringify(!!useDeprecatedAdapterComponent);
        return WebpackPlugin_1.default.getDefinePlugin([envConstants, defineConstants]);
    }
    getCopyWebpackPlugin() {
        const { appPath, config } = this.combination;
        const { copy } = config;
        if (copy === null || copy === void 0 ? void 0 : copy.patterns.length) {
            return WebpackPlugin_1.default.getCopyWebpackPlugin(appPath, copy);
        }
    }
    getMiniCssExtractPlugin() {
        const { mode, enableExtract = mode === 'production', miniCssExtractPluginOption = {} } = this.combination.config;
        if (!enableExtract)
            return;
        const args = Object.assign({
            filename: 'css/[name].css',
            chunkFilename: 'css/[name].css'
        }, miniCssExtractPluginOption);
        return WebpackPlugin_1.default.getMiniCssExtractPlugin(args);
    }
    getHtmlWebpackPlugin(template, entry = '', chunks = []) {
        var _a, _b, _c, _d, _e;
        const config = this.combination.config || {};
        const options = ((_a = this.pxtransformOption) === null || _a === void 0 ? void 0 : _a.config) || {};
        const max = (_b = options === null || options === void 0 ? void 0 : options.maxRootSize) !== null && _b !== void 0 ? _b : 40;
        const min = (_c = options === null || options === void 0 ? void 0 : options.minRootSize) !== null && _c !== void 0 ? _c : 20;
        const baseFontSize = (options === null || options === void 0 ? void 0 : options.baseFontSize) || (min > 1 ? min : 20);
        const designWidth = (input => typeof options.designWidth === 'function'
            ? options.designWidth(input)
            : options.designWidth)(baseFontSize);
        const rootValue = baseFontSize / options.deviceRatio[designWidth] * 2;
        let htmlScript = '';
        if (((_d = options === null || options === void 0 ? void 0 : options.targetUnit) !== null && _d !== void 0 ? _d : 'rem') === 'rem') {
            htmlScript = `!function(n){function f(){var e=n.document.documentElement,w=e.getBoundingClientRect().width,x=${rootValue}*w/${designWidth};e.style.fontSize=x>=${max}?"${max}px":x<=${min}?"${min}px":x+"px"}n.addEventListener("resize",(function(){f()})),f()}(window);`;
        }
        const args = {
            filename: `${entry || 'index'}.html`,
            script: htmlScript,
            template,
        };
        if (entry && entry !== 'index') {
            args.chunks = [...chunks, entry];
        }
        const htmlPluginOption = (_e = config.htmlPluginOption) !== null && _e !== void 0 ? _e : {};
        if (config.mode !== 'production' && Object.hasOwnProperty.call(htmlPluginOption, 'script')) {
            console.warn(helper_1.chalk.yellowBright('配置文件覆盖 htmlPluginOption.script 参数会导致 pxtransform 脚本失效，请慎重使用！'));
        }
        return WebpackPlugin_1.default.getPlugin(html_webpack_plugin_1.default, [(0, helper_1.recursiveMerge)(args, htmlPluginOption)]);
    }
    getMainPlugin() {
        var _a;
        const { appPath, sourceDir, config } = this.combination;
        const { entryFileName = 'app', router = {} } = config;
        const pxTransformConfig = ((_a = this.pxtransformOption) === null || _a === void 0 ? void 0 : _a.config) || {};
        const prebundleOptions = this.combination.getPrebundleOptions();
        const options = {
            /** paths */
            appPath,
            sourceDir,
            entryFileName,
            /** config & message */
            framework: config.framework,
            frameworkExts: config.frameworkExts,
            routerConfig: router,
            runtimePath: config.runtimePath,
            pxTransformConfig,
            alias: config.alias,
            defineConstants: config.defineConstants,
            /** building mode */
            prebundle: prebundleOptions.enable,
            isBuildNativeComp: this.combination.isBuildNativeComp,
            /** hooks & methods */
            onCompilerMake: config.onCompilerMake,
            onParseCreateElement: config.onParseCreateElement,
        };
        return WebpackPlugin_1.default.getPlugin(H5Plugin_1.default, [options]);
    }
}
exports.H5WebpackPlugin = H5WebpackPlugin;
//# sourceMappingURL=H5WebpackPlugin.js.map