"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.printCompiling = exports.printBuildError = exports.getServeSpinner = exports.bindProdLogger = exports.bindDevLogger = exports.printPrerenderFail = exports.printPrerenderSuccess = void 0;
const helper_1 = require("@tarojs/helper");
const fp_1 = require("lodash/fp");
const ora_1 = __importDefault(require("ora"));
const webpack_format_messages_1 = __importDefault(require("webpack-format-messages"));
const getServeSpinner = (() => {
    let spinner;
    return () => {
        if (!spinner) {
            spinner = (0, ora_1.default)('即将开始启动编译，请稍等~');
            spinner.start();
        }
        return spinner;
    };
})();
exports.getServeSpinner = getServeSpinner;
const printCompiling = () => {
    getServeSpinner().text = '正在编译...';
};
exports.printCompiling = printCompiling;
const printBuildError = (err) => {
    const message = err.message;
    const stack = err.stack;
    if (stack && message.indexOf('from UglifyJs') !== -1) {
        try {
            const matched = /(.+)\[(.+):(.+),(.+)\]\[.+\]/.exec(stack);
            if (!matched) {
                throw new Error('Using errors for control flow is bad.');
            }
            const problemPath = matched[2];
            const line = matched[3];
            const column = matched[4];
            console.log('Failed to minify the code from this file: \n\n', helper_1.chalk.yellow(`\t${problemPath}:${line}${column !== '0' ? ':' + column : ''}`), '\n');
        }
        catch (ignored) {
            console.log('Failed to minify the bundle.', err);
        }
    }
    else {
        console.log((message || err) + '\n');
    }
    console.log();
};
exports.printBuildError = printBuildError;
const printSuccess = () => {
    getServeSpinner().stopAndPersist({
        symbol: '✅ ',
        text: helper_1.chalk.green(`编译成功 ${new Date().toLocaleString()}\n`)
    });
};
const printPrerenderSuccess = (path) => {
    getServeSpinner().stopAndPersist({
        symbol: '🚀 ',
        text: helper_1.chalk.green(`页面 ${path} 预渲染成功 ${new Date().toLocaleString()}`)
    });
};
exports.printPrerenderSuccess = printPrerenderSuccess;
const printPrerenderFail = (path) => {
    getServeSpinner().stopAndPersist({
        symbol: '⚠️ ',
        text: helper_1.chalk.yellow(`${new Date().toLocaleString()} 页面 ${path} 预渲染失败：`)
    });
};
exports.printPrerenderFail = printPrerenderFail;
const printWarning = () => {
    getServeSpinner().stopAndPersist({
        symbol: '⚠️ ',
        text: helper_1.chalk.yellow(`编译警告. ${new Date().toLocaleString()}\n`)
    });
};
const printFailed = () => {
    getServeSpinner().stopAndPersist({
        symbol: '🙅  ',
        text: helper_1.chalk.red(`编译失败. ${new Date().toLocaleString()}\n`)
    });
};
const printWhenBeforeCompile = compiler => {
    compiler.hooks.beforeCompile.tap('taroBeforeCompile', () => {
        printCompiling();
    });
    return compiler;
};
const printWhenInvalid = compiler => {
    compiler.hooks.invalid.tap('taroInvalid', () => {
        printCompiling();
    });
    return compiler;
};
const printWhenFailed = compiler => {
    compiler.hooks.failed.tap('taroFailed', error => {
        printBuildError(error);
    });
    return compiler;
};
let isFirst = true;
const printWhenFirstDone = (devUrl, compiler) => {
    compiler.hooks.done.tap('taroDone', () => {
        if (isFirst) {
            isFirst = false;
            getServeSpinner().clear();
            if (devUrl) {
                console.log();
                console.log(helper_1.chalk.cyan(`ℹ️  Listening at ${devUrl}`));
            }
            console.log(helper_1.chalk.gray('\n监听文件修改中...\n'));
        }
    });
    return compiler;
};
const _printWhenDone = ({ verbose = false }, compiler) => {
    compiler.hooks.done.tap('taroDone', stats => {
        const { errors, warnings } = (0, webpack_format_messages_1.default)(stats);
        if (!stats.hasErrors() && !stats.hasWarnings()) {
            printSuccess();
        }
        if (stats.hasErrors()) {
            printFailed();
            errors.forEach(e => console.log(e + '\n'));
            verbose && process.exit(1);
            return;
        }
        if (stats.hasWarnings()) {
            printWarning();
            warnings.forEach(w => console.log(w + '\n'));
        }
        verbose && console.log(stats.toString({
            colors: true,
            modules: false,
            children: false,
            chunks: false,
            chunkModules: false,
            warnings: verbose
        }) + '\n');
    });
    return compiler;
};
const printWhenDone = (0, fp_1.partial)(_printWhenDone, [{ verbose: false }]);
const printWhenDoneVerbosely = (0, fp_1.partial)(_printWhenDone, [{ verbose: true }]);
const bindDevLogger = (compiler, devUrl = '') => {
    console.log();
    (0, fp_1.pipe)(printWhenBeforeCompile, printWhenDone, printWhenFailed, printWhenInvalid, (0, fp_1.partial)(printWhenFirstDone, [devUrl]))(compiler);
    return compiler;
};
exports.bindDevLogger = bindDevLogger;
const bindProdLogger = compiler => {
    console.log();
    (0, fp_1.pipe)(printWhenBeforeCompile, printWhenDoneVerbosely, printWhenFailed)(compiler);
    return compiler;
};
exports.bindProdLogger = bindProdLogger;
//# sourceMappingURL=logHelper.js.map