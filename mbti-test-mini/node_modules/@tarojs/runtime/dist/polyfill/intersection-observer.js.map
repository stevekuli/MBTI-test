{"version":3,"file":"intersection-observer.js","sources":["../../src/polyfill/intersection-observer.ts"],"sourcesContent":["/* eslint-disable eqeqeq */\nimport { isFunction, isNumber } from '@tarojs/shared'\n\nimport { throttle } from '../utils'\n\nexport function handleIntersectionObserverPolyfill () {\n  // Exit early if all IntersectionObserver and IntersectionObserverEntry\n  // features are natively supported.\n  if (\n    'IntersectionObserver' in window &&\n    'IntersectionObserverEntry' in window &&\n    'intersectionRatio' in window.IntersectionObserverEntry.prototype\n  ) {\n    if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n      // Minimal polyfill for Edge 15's lack of `isIntersecting`\n      // See: https://github.com/w3c/IntersectionObserver/issues/211\n      Object.defineProperty(window.IntersectionObserverEntry.prototype, 'isIntersecting', {\n        get: function () {\n          return this.intersectionRatio > 0\n        }\n      })\n    }\n  } else {\n    handleIntersectionObserverObjectPolyfill()\n  }\n}\n\nfunction handleIntersectionObserverObjectPolyfill () {\n  const document = window.document\n\n  /**\n   * An IntersectionObserver registry. This registry exists to hold a strong\n   * reference to IntersectionObserver instances currently observing a target\n   * element. Without this registry, instances without another reference may be\n   * garbage collected.\n   */\n  const registry: number[] = []\n\n  /**\n   * Creates the global IntersectionObserverEntry constructor.\n   * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n   * @param {Object} entry A dictionary of instance properties.\n   * @constructor\n   */\n  function IntersectionObserverEntry (entry: IntersectionObserverEntryInit) {\n    this.time = entry.time\n    this.target = entry.target\n    this.rootBounds = entry.rootBounds\n    this.boundingClientRect = entry.boundingClientRect\n    this.intersectionRect = entry.intersectionRect || getEmptyRect()\n    this.isIntersecting = !!entry.intersectionRect\n\n    // Calculates the intersection ratio.\n    const targetRect = this.boundingClientRect\n    const targetArea = targetRect.width * targetRect.height\n    const intersectionRect = this.intersectionRect\n    const intersectionArea = intersectionRect.width * intersectionRect.height\n\n    // Sets intersection ratio.\n    if (targetArea) {\n    // Round the intersection ratio to avoid floating point math issues:\n    // https://github.com/w3c/IntersectionObserver/issues/324\n      this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4))\n    } else {\n    // If area is zero and is intersecting, sets to 1, otherwise to 0\n      this.intersectionRatio = this.isIntersecting ? 1 : 0\n    }\n  }\n\n  /**\n   * Creates the global IntersectionObserver constructor.\n   * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n   * @param {Function} callback The function to be invoked after intersection\n   *     changes have queued. The function is not invoked if the queue has\n   *     been emptied by calling the `takeRecords` method.\n   * @param {Object=} opt_options Optional configuration options.\n   * @constructor\n   */\n  function IntersectionObserver (callback: IntersectionObserverCallback, options: IntersectionObserverInit = {}) {\n    if (!isFunction(callback)) {\n      throw new Error('callback must be a function')\n    }\n\n    if (options.root && options.root.nodeType != 1) {\n      throw new Error('root must be an Element')\n    }\n\n    // Binds and throttles `this._checkForIntersections`.\n    this._checkForIntersections = throttle(\n      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT)\n\n    // Private properties.\n    this._callback = callback\n    this._observationTargets = []\n    this._queuedEntries = []\n    this._rootMarginValues = this._parseRootMargin(options.rootMargin)\n\n    // Public properties.\n    this.thresholds = this._initThresholds(options.threshold)\n    this.root = options.root || null\n    this.rootMargin = this._rootMarginValues.map(function (margin) {\n      return margin.value + margin.unit\n    }).join(' ')\n  }\n\n  /**\n   * The minimum interval within which the document will be checked for\n   * intersection changes.\n   */\n  IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100\n\n  /**\n   * The frequency in which the polyfill polls for intersection changes.\n   * this can be updated on a per instance basis and must be set prior to\n   * calling `observe` on the first target.\n   */\n  IntersectionObserver.prototype.POLL_INTERVAL = null\n\n  /**\n   * Use a mutation observer on the root element\n   * to detect intersection changes.\n   */\n  IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true\n\n  /**\n   * Starts observing a target element for intersection changes based on\n   * the thresholds values.\n   * @param {Element} target The DOM element to observe.\n   */\n  IntersectionObserver.prototype.observe = function (target) {\n    const isTargetAlreadyObserved = this._observationTargets.some(function (item) {\n      return item.element == target\n    })\n\n    if (isTargetAlreadyObserved) return\n\n    if (!(target && target.nodeType == 1)) {\n      throw new Error('target must be an Element')\n    }\n\n    this._registerInstance()\n    this._observationTargets.push({ element: target, entry: null })\n    this._monitorIntersections()\n    this._checkForIntersections()\n  }\n\n  /**\n   * Stops observing a target element for intersection changes.\n   * @param {Element} target The DOM element to observe.\n   */\n  IntersectionObserver.prototype.unobserve = function (target) {\n    this._observationTargets =\n    this._observationTargets.filter(function (item) {\n      return item.element != target\n    })\n    if (!this._observationTargets.length) {\n      this._unmonitorIntersections()\n      this._unregisterInstance()\n    }\n  }\n\n  /**\n   * Stops observing all target elements for intersection changes.\n   */\n  IntersectionObserver.prototype.disconnect = function () {\n    this._observationTargets = []\n    this._unmonitorIntersections()\n    this._unregisterInstance()\n  }\n\n  /**\n   * Returns any queue entries that have not yet been reported to the\n   * callback and clears the queue. This can be used in conjunction with the\n   * callback to obtain the absolute most up-to-date intersection information.\n   * @return {Array} The currently queued entries.\n   */\n  IntersectionObserver.prototype.takeRecords = function () {\n    const records = this._queuedEntries.slice()\n    this._queuedEntries = []\n    return records\n  }\n\n  /**\n   * Accepts the threshold value from the user configuration object and\n   * returns a sorted array of unique threshold values. If a value is not\n   * between 0 and 1 and error is thrown.\n   * @private\n   * @param {Array|number=} opt_threshold An optional threshold value or\n   *     a list of threshold values, defaulting to [0].\n   * @return {Array} A sorted list of unique and valid threshold values.\n   */\n  IntersectionObserver.prototype._initThresholds = function (opt_threshold) {\n    let threshold = opt_threshold || [0]\n    if (!Array.isArray(threshold)) threshold = [threshold]\n\n    return threshold.sort().filter(function (t, i, a) {\n      if (!isNumber(t) || isNaN(t) || t < 0 || t > 1) {\n        throw new Error('threshold must be a number between 0 and 1 inclusively')\n      }\n      return t !== a[i - 1]\n    })\n  }\n\n  /**\n   * Accepts the rootMargin value from the user configuration object\n   * and returns an array of the four margin values as an object containing\n   * the value and unit properties. If any of the values are not properly\n   * formatted or use a unit other than px or %, and error is thrown.\n   * @private\n   * @param {string=} opt_rootMargin An optional rootMargin value,\n   *     defaulting to '0px'.\n   * @return {Array<Object>} An array of margin objects with the keys\n   *     value and unit.\n   */\n  IntersectionObserver.prototype._parseRootMargin = function (opt_rootMargin) {\n    const marginString = opt_rootMargin || '0px'\n    const margins = marginString.split(/\\s+/).map(function (margin) {\n      const parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin)\n      if (!parts) {\n        throw new Error('rootMargin must be specified in pixels or percent')\n      }\n      return { value: parseFloat(parts[1]), unit: parts[2] }\n    })\n\n    // Handles shorthand.\n    margins[1] = margins[1] || margins[0]\n    margins[2] = margins[2] || margins[0]\n    margins[3] = margins[3] || margins[1]\n\n    return margins\n  }\n\n  /**\n   * Starts polling for intersection changes if the polling is not already\n   * happening, and if the page's visibility state is visible.\n   * @private\n   */\n  IntersectionObserver.prototype._monitorIntersections = function () {\n    if (!this._monitoringIntersections) {\n      this._monitoringIntersections = true\n\n      // If a poll interval is set, use polling instead of listening to\n      // resize and scroll events or DOM mutations.\n      if (this.POLL_INTERVAL) {\n        this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL)\n      } else {\n        addEvent(window, 'resize', this._checkForIntersections, true)\n        addEvent(document, 'scroll', this._checkForIntersections, true)\n\n        if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {\n          this._domObserver = new MutationObserver(this._checkForIntersections)\n          this._domObserver.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true\n          })\n        }\n      }\n    }\n  }\n\n  /**\n   * Stops polling for intersection changes.\n   * @private\n   */\n  IntersectionObserver.prototype._unmonitorIntersections = function () {\n    if (this._monitoringIntersections) {\n      this._monitoringIntersections = false\n\n      clearInterval(this._monitoringInterval)\n      this._monitoringInterval = null\n\n      removeEvent(window, 'resize', this._checkForIntersections, true)\n      removeEvent(document, 'scroll', this._checkForIntersections, true)\n\n      if (this._domObserver) {\n        this._domObserver.disconnect()\n        this._domObserver = null\n      }\n    }\n  }\n\n  /**\n   * Scans each observation target for intersection changes and adds them\n   * to the internal entries queue. If new entries are found, it\n   * schedules the callback to be invoked.\n   * @private\n   */\n  IntersectionObserver.prototype._checkForIntersections = function () {\n    const rootIsInDom = this._rootIsInDom()\n    const rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect()\n\n    this._observationTargets.forEach(function (item) {\n      const target = item.element\n      const targetRect = getBoundingClientRect(target)\n      const rootContainsTarget = this._rootContainsTarget(target)\n      const oldEntry = item.entry\n      const intersectionRect = rootIsInDom && rootContainsTarget &&\n      this._computeTargetAndRootIntersection(target, rootRect)\n\n      const newEntry = item.entry = new IntersectionObserverEntry({\n        time: now(),\n        target: target,\n        boundingClientRect: targetRect,\n        rootBounds: rootRect,\n        intersectionRect: intersectionRect,\n        intersectionRatio: -1,\n        isIntersecting: false,\n      })\n\n      if (!oldEntry) {\n        this._queuedEntries.push(newEntry)\n      } else if (rootIsInDom && rootContainsTarget) {\n      // If the new entry intersection ratio has crossed any of the\n      // thresholds, add a new entry.\n        if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n          this._queuedEntries.push(newEntry)\n        }\n      } else {\n      // If the root is not in the DOM or target is not contained within\n      // root but the previous entry for this target had an intersection,\n      // add a new record indicating removal.\n        if (oldEntry && oldEntry.isIntersecting) {\n          this._queuedEntries.push(newEntry)\n        }\n      }\n    }, this)\n\n    if (this._queuedEntries.length) {\n      this._callback(this.takeRecords(), this)\n    }\n  }\n\n  /**\n   * Accepts a target and root rect computes the intersection between then\n   * following the algorithm in the spec.\n   * TODO(philipwalton): at this time clip-path is not considered.\n   * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n   * @param {Element} target The target DOM element\n   * @param {Object} rootRect The bounding rect of the root after being\n   *     expanded by the rootMargin value.\n   * @return {?Object} The final intersection rect object or undefined if no\n   *     intersection is found.\n   * @private\n   */\n  IntersectionObserver.prototype._computeTargetAndRootIntersection = function (target, rootRect) {\n    // If the element isn't displayed, an intersection can't happen.\n    if (window.getComputedStyle(target).display === 'none') return\n\n    const targetRect = getBoundingClientRect(target)\n    let intersectionRect = targetRect\n    let parent = getParentNode(target)\n    let atRoot = false\n\n    while (!atRoot) {\n      let parentRect = null\n      const parentComputedStyle: Partial<CSSStyleDeclaration> = parent.nodeType == 1 ?\n        window.getComputedStyle(parent) : {}\n\n      // If the parent isn't displayed, an intersection can't happen.\n      if (parentComputedStyle.display === 'none') return\n\n      if (parent == this.root || parent == document) {\n        atRoot = true\n        parentRect = rootRect\n      } else {\n        // If the element has a non-visible overflow, and it's not the <body>\n        // or <html> element, update the intersection rect.\n        // Note: <body> and <html> cannot be clipped to a rect that's not also\n        // the document rect, so no need to compute a new intersection.\n        if (parent != document.body &&\n          parent != document.documentElement &&\n          parentComputedStyle.overflow != 'visible') {\n          parentRect = getBoundingClientRect(parent)\n        }\n      }\n\n      // If either of the above conditionals set a new parentRect,\n      // calculate new intersection data.\n      if (parentRect) {\n        intersectionRect = computeRectIntersection(parentRect, intersectionRect)\n\n        if (!intersectionRect) break\n      }\n      parent = getParentNode(parent)\n    }\n    return intersectionRect\n  }\n\n\n  /**\n * Returns the root rect after being expanded by the rootMargin value.\n * @return {Object} The expanded root rect.\n * @private\n */\n  IntersectionObserver.prototype._getRootRect = function () {\n    let rootRect\n    if (this.root) {\n      rootRect = getBoundingClientRect(this.root)\n    } else {\n    // Use <html>/<body> instead of window since scroll bars affect size.\n      const html = document.documentElement\n      const body = document.body\n      rootRect = {\n        top: 0,\n        left: 0,\n        right: html.clientWidth || body.clientWidth,\n        width: html.clientWidth || body.clientWidth,\n        bottom: html.clientHeight || body.clientHeight,\n        height: html.clientHeight || body.clientHeight\n      }\n    }\n    return this._expandRectByRootMargin(rootRect)\n  }\n\n  /**\n   * Accepts a rect and expands it by the rootMargin value.\n   * @param {Object} rect The rect object to expand.\n   * @return {Object} The expanded rect.\n   * @private\n   */\n  IntersectionObserver.prototype._expandRectByRootMargin = function (rect) {\n    const margins = this._rootMarginValues.map(function (margin, i) {\n      return margin.unit === 'px' ? margin.value :\n        margin.value * (i % 2 ? rect.width : rect.height) / 100\n    })\n    const newRect: Record<string, number> = {\n      top: rect.top - margins[0],\n      right: rect.right + margins[1],\n      bottom: rect.bottom + margins[2],\n      left: rect.left - margins[3]\n    }\n    newRect.width = newRect.right - newRect.left\n    newRect.height = newRect.bottom - newRect.top\n\n    return newRect\n  }\n\n  /**\n   * Accepts an old and new entry and returns true if at least one of the\n   * threshold values has been crossed.\n   * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n   *    particular target element or null if no previous entry exists.\n   * @param {IntersectionObserverEntry} newEntry The current entry for a\n   *    particular target element.\n   * @return {boolean} Returns true if a any threshold has been crossed.\n   * @private\n   */\n  IntersectionObserver.prototype._hasCrossedThreshold =\n  function (oldEntry, newEntry) {\n    // To make comparing easier, an entry that has a ratio of 0\n    // but does not actually intersect is given a value of -1\n    const oldRatio = oldEntry && oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1\n    const newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1\n\n    // Ignore unchanged ratios\n    if (oldRatio === newRatio) return\n\n    for (let i = 0; i < this.thresholds.length; i++) {\n      const threshold = this.thresholds[i]\n\n      // Return true if an entry matches a threshold or if the new ratio\n      // and the old ratio are on the opposite sides of a threshold.\n      if (threshold == oldRatio || threshold == newRatio ||\n        threshold < oldRatio !== threshold < newRatio) {\n        return true\n      }\n    }\n  }\n\n  /**\n   * Returns whether or not the root element is an element and is in the DOM.\n   * @return {boolean} True if the root element is an element and is in the DOM.\n   * @private\n   */\n  IntersectionObserver.prototype._rootIsInDom = function () {\n    return !this.root || containsDeep(document, this.root)\n  }\n\n  /**\n   * Returns whether or not the target element is a child of root.\n   * @param {Element} target The target element to check.\n   * @return {boolean} True if the target element is a child of root.\n   * @private\n   */\n  IntersectionObserver.prototype._rootContainsTarget = function (target) {\n    return containsDeep(this.root || document, target)\n  }\n\n  /**\n   * Adds the instance to the global IntersectionObserver registry if it isn't\n   * already present.\n   * @private\n   */\n  IntersectionObserver.prototype._registerInstance = function () {\n    if (registry.indexOf(this) < 0) {\n      registry.push(this)\n    }\n  }\n\n  /**\n * Removes the instance from the global IntersectionObserver registry.\n * @private\n */\n  IntersectionObserver.prototype._unregisterInstance = function () {\n    const index = registry.indexOf(this)\n    if (index != -1) registry.splice(index, 1)\n  }\n\n  /**\n   * Returns the result of the performance.now() method or null in browsers\n   * that don't support the API.\n   * @return {number} The elapsed time since the page was requested.\n   */\n  function now () {\n    return window.performance && performance.now && performance.now()\n  }\n\n  /**\n   * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n   * @param {Node} node The DOM node to add the event handler to.\n   * @param {string} event The event name.\n   * @param {Function} fn The event handler to add.\n   * @param {boolean} opt_useCapture Optionally adds the even to the capture\n   *     phase. Note: this only works in modern browsers.\n   */\n  function addEvent (node, event, fn, opt_useCapture) {\n    if (isFunction(node.addEventListener)) {\n      node.addEventListener(event, fn, opt_useCapture || false)\n    } else if (isFunction(node.attachEvent)) {\n      node.attachEvent('on' + event, fn)\n    }\n  }\n\n  /**\n   * Removes a previously added event handler from a DOM node.\n   * @param {Node} node The DOM node to remove the event handler from.\n   * @param {string} event The event name.\n   * @param {Function} fn The event handler to remove.\n   * @param {boolean} opt_useCapture If the event handler was added with this\n   *     flag set to true, it should be set to true here in order to remove it.\n   */\n  function removeEvent (node, event, fn, opt_useCapture) {\n    if (isFunction(node.removeEventListener)) {\n      node.removeEventListener(event, fn, opt_useCapture || false)\n    }\n    else if (isFunction(node.detatchEvent)) {\n      node.detatchEvent('on' + event, fn)\n    }\n  }\n\n  /**\n   * Returns the intersection between two rect objects.\n   * @param {Object} rect1 The first rect.\n   * @param {Object} rect2 The second rect.\n   * @return {?Object} The intersection rect or undefined if no intersection\n   *     is found.\n   */\n  function computeRectIntersection (rect1, rect2) {\n    const top = Math.max(rect1.top, rect2.top)\n    const bottom = Math.min(rect1.bottom, rect2.bottom)\n    const left = Math.max(rect1.left, rect2.left)\n    const right = Math.min(rect1.right, rect2.right)\n    const width = right - left\n    const height = bottom - top\n\n    return (width >= 0 && height >= 0) && {\n      top: top,\n      bottom: bottom,\n      left: left,\n      right: right,\n      width: width,\n      height: height\n    }\n  }\n\n  /**\n   * Shims the native getBoundingClientRect for compatibility with older IE.\n   * @param {Element} el The element whose bounding rect to get.\n   * @return {Object} The (possibly shimmed) rect of the element.\n   */\n  function getBoundingClientRect (el) {\n    let rect\n\n    try {\n      rect = el.getBoundingClientRect()\n    } catch (err) {\n    // Ignore Windows 7 IE11 \"Unspecified error\"\n    // https://github.com/w3c/IntersectionObserver/pull/205\n    }\n\n    if (!rect) return getEmptyRect()\n\n    // Older IE\n    if (!(rect.width && rect.height)) {\n      rect = {\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n      }\n    }\n    return rect\n  }\n\n  /**\n   * Returns an empty rect object. An empty rect is returned when an element\n   * is not in the DOM.\n   * @return {Object} The empty rect.\n   */\n  function getEmptyRect () {\n    return {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      width: 0,\n      height: 0\n    }\n  }\n\n  /**\n   * Checks to see if a parent element contains a child element (including inside\n   * shadow DOM).\n   * @param {Node} parent The parent element.\n   * @param {Node} child The child element.\n   * @return {boolean} True if the parent node contains the child node.\n   */\n  function containsDeep (parent, child) {\n    let node = child\n    while (node) {\n      if (node == parent) return true\n\n      node = getParentNode(node)\n    }\n    return false\n  }\n\n  /**\n   * Gets the parent node of an element or its host element if the parent node\n   * is a shadow root.\n   * @param {Node} node The node whose parent to get.\n   * @return {Node|null} The parent node or null if no parent exists.\n   */\n  function getParentNode (node) {\n    const parent = node.parentNode\n\n    if (parent && parent.nodeType == 11 && parent.host) {\n    // If the parent is a shadow root, return the host element.\n      return parent.host\n    }\n\n    if (parent && parent.assignedSlot) {\n    // If the parent is distributed in a <slot>, return the parent of a slot.\n      return parent.assignedSlot.parentNode\n    }\n\n    return parent\n  }\n\n  // Exposes the constructors globally.\n  window.IntersectionObserver = IntersectionObserver as unknown as typeof window.IntersectionObserver\n  window.IntersectionObserverEntry = IntersectionObserverEntry as unknown as typeof window.IntersectionObserverEntry\n}\n"],"names":[],"mappings":"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"}