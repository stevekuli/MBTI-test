import { EMPTY_OBJ, isFunction, isArray, hooks, ensure, isUndefined } from '@tarojs/shared';
import { Current, getPageInstance, injectPageInstance, incrementId, document, getPath, window, CONTEXT_ACTIONS, safeExecute, removePageInstance, ON_READY, requestAnimationFrame, eventCenter, getOnReadyEventKey, ON_SHOW, getOnShowEventKey, ON_HIDE, getOnHideEventKey, eventHandler, addLeadingSlash } from '@tarojs/runtime';

const reactMeta = {
    PageContext: EMPTY_OBJ,
    R: EMPTY_OBJ
};

const HOOKS_APP_ID = 'taro-app';
function isClassComponent(R, component) {
    var _a;
    const prototype = component.prototype;
    // For React Redux
    if ((_a = component.displayName) === null || _a === void 0 ? void 0 : _a.includes('Connect'))
        return false;
    return (isFunction(component.render) ||
        !!(prototype === null || prototype === void 0 ? void 0 : prototype.isReactComponent) ||
        prototype instanceof R.Component // compat for some others react-like library
    );
}
function ensureIsArray(item) {
    if (isArray(item)) {
        return item;
    }
    else {
        return item ? [item] : [];
    }
}
/**
 * set writable, enumerable to true
 */
function setDefaultDescriptor(obj) {
    obj.writable = true;
    obj.enumerable = true;
    return obj;
}
/**
 * 设置入口的路由参数
 * @param options 小程序传入的参数
 */
function setRouterParams(options) {
    Current.router = Object.assign({ params: options === null || options === void 0 ? void 0 : options.query }, options);
}

const createTaroHook = (lifecycle) => {
    return (fn) => {
        const { R: React, PageContext } = reactMeta;
        const id = React.useContext(PageContext) || HOOKS_APP_ID;
        const instRef = React.useRef();
        // hold fn ref and keep up to date
        const fnRef = React.useRef(fn);
        if (fnRef.current !== fn)
            fnRef.current = fn;
        React.useLayoutEffect(() => {
            let inst = instRef.current = getPageInstance(id);
            let first = false;
            if (!inst) {
                first = true;
                instRef.current = Object.create(null);
                inst = instRef.current;
            }
            // callback is immutable but inner function is up to date
            const callback = (...args) => fnRef.current(...args);
            if (isFunction(inst[lifecycle])) {
                (inst[lifecycle]) = [inst[lifecycle], callback];
            }
            else {
                (inst[lifecycle]) = [
                    ...((inst[lifecycle]) || []),
                    callback
                ];
            }
            if (first) {
                injectPageInstance(inst, id);
            }
            return () => {
                const inst = instRef.current;
                if (!inst)
                    return;
                const list = inst[lifecycle];
                if (list === callback) {
                    (inst[lifecycle]) = undefined;
                }
                else if (isArray(list)) {
                    (inst[lifecycle]) = list.filter(item => item !== callback);
                }
                instRef.current = undefined;
            };
        }, []);
    };
};
/** LifeCycle */
const useDidHide = createTaroHook('componentDidHide');
const useDidShow = createTaroHook('componentDidShow');
/** App */
const useError = createTaroHook('onError');
const useUnhandledRejection = createTaroHook('onUnhandledRejection');
const useLaunch = createTaroHook('onLaunch');
const usePageNotFound = createTaroHook('onPageNotFound');
/** Page */
const useLoad = createTaroHook('onLoad');
const usePageScroll = createTaroHook('onPageScroll');
const usePullDownRefresh = createTaroHook('onPullDownRefresh');
const usePullIntercept = createTaroHook('onPullIntercept');
const useReachBottom = createTaroHook('onReachBottom');
const useResize = createTaroHook('onResize');
const useUnload = createTaroHook('onUnload');
/** Mini-Program */
const useAddToFavorites = createTaroHook('onAddToFavorites');
const useOptionMenuClick = createTaroHook('onOptionMenuClick');
const useSaveExitState = createTaroHook('onSaveExitState');
const useShareAppMessage = createTaroHook('onShareAppMessage');
const useShareTimeline = createTaroHook('onShareTimeline');
const useTitleClick = createTaroHook('onTitleClick');
/** Router */
const useReady = createTaroHook('onReady');
const useRouter = (dynamic = false) => {
    const React = reactMeta.R;
    return dynamic ? Current.router : React.useMemo(() => Current.router, []);
};
const useTabItemTap = createTaroHook('onTabItemTap');
const useScope = () => undefined;

var taroHooks = /*#__PURE__*/Object.freeze({
  __proto__: null,
  useAddToFavorites: useAddToFavorites,
  useDidHide: useDidHide,
  useDidShow: useDidShow,
  useError: useError,
  useLaunch: useLaunch,
  useLoad: useLoad,
  useOptionMenuClick: useOptionMenuClick,
  usePageNotFound: usePageNotFound,
  usePageScroll: usePageScroll,
  usePullDownRefresh: usePullDownRefresh,
  usePullIntercept: usePullIntercept,
  useReachBottom: useReachBottom,
  useReady: useReady,
  useResize: useResize,
  useRouter: useRouter,
  useSaveExitState: useSaveExitState,
  useScope: useScope,
  useShareAppMessage: useShareAppMessage,
  useShareTimeline: useShareTimeline,
  useTabItemTap: useTabItemTap,
  useTitleClick: useTitleClick,
  useUnhandledRejection: useUnhandledRejection,
  useUnload: useUnload
});

let h$1;
let ReactDOM$1;
let Fragment;
const pageKeyId = incrementId();
function setReconciler(ReactDOM) {
    hooks.tap('getLifecycle', function (instance, lifecycle) {
        lifecycle = lifecycle.replace(/^on(Show|Hide)$/, 'componentDid$1');
        return instance[lifecycle];
    });
    hooks.tap('modifyMpEvent', function (event) {
        // Note: ohos 上事件没有设置 type 类型 setter 方法导致报错
        Object.defineProperty(event, 'type', {
            value: event.type.replace(/-/g, '')
        });
    });
    hooks.tap('batchedEventUpdates', function (cb) {
        ReactDOM.unstable_batchedUpdates(cb);
    });
    hooks.tap('mergePageInstance', function (prev, next) {
        if (!prev || !next)
            return;
        // 子组件使用 lifecycle hooks 注册了生命周期后，会存在 prev，里面是注册的生命周期回调。
        // prev 使用 Object.create(null) 创建，H5 的 fast-refresh 可能也会导致存在 prev，要排除这些意外产生的 prev
        if ('constructor' in prev)
            return;
        Object.keys(prev).forEach(item => {
            const prevList = prev[item];
            const nextList = ensureIsArray(next[item]);
            next[item] = nextList.concat(prevList);
        });
    });
    if (process.env.TARO_PLATFORM === 'web') {
        hooks.tap('createPullDownComponent', (el, _, R, customWrapper) => {
            const isReactComponent = isClassComponent(R, el);
            return R.forwardRef((props, ref) => {
                const newProps = Object.assign({}, props);
                const refs = isReactComponent ? { ref: ref } : {
                    forwardedRef: ref,
                    // 兼容 react-redux 7.20.1+
                    reactReduxForwardedRef: ref
                };
                return h$1(customWrapper || 'taro-pull-to-refresh-core', null, h$1(el, Object.assign(Object.assign({}, newProps), refs)));
            });
        });
        hooks.tap('getDOMNode', (inst) => {
            // 由于react 18移除了ReactDOM.findDOMNode方法，修复H5端 Taro.createSelectorQuery设置in(scope)时，报错问题
            // https://zh-hans.react.dev/reference/react-dom/findDOMNode
            if (!inst) {
                return document;
            }
            else if (inst instanceof HTMLElement) {
                return inst;
            }
            else if (inst.$taroPath) {
                const el = document.getElementById(inst.$taroPath);
                return el !== null && el !== void 0 ? el : document;
            }
        });
    }
}
function connectReactPage(R, id) {
    return (Page) => {
        // eslint-disable-next-line dot-notation
        const isReactComponent = isClassComponent(R, Page);
        const inject = (node) => node && injectPageInstance(node, id);
        const refs = isReactComponent ? { ref: inject } : {
            forwardedRef: inject,
            // 兼容 react-redux 7.20.1+
            reactReduxForwardedRef: inject
        };
        if (reactMeta.PageContext === EMPTY_OBJ) {
            reactMeta.PageContext = R.createContext('');
        }
        return class PageWrapper extends R.Component {
            constructor() {
                super(...arguments);
                this.state = {
                    hasError: false
                };
            }
            static getDerivedStateFromError(error) {
                var _a, _b;
                (_b = (_a = Current.app) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, error.message + error.stack);
                return { hasError: true };
            }
            // React 16 uncaught error 会导致整个应用 crash，
            // 目前把错误缩小到页面
            componentDidCatch(error, info) {
                if (process.env.NODE_ENV !== 'production') {
                    console.warn(error);
                    console.error(info.componentStack);
                }
            }
            render() {
                const children = this.state.hasError
                    ? []
                    : h$1(reactMeta.PageContext.Provider, { value: id }, h$1(Page, Object.assign(Object.assign({}, this.props), refs)));
                if (process.env.TARO_PLATFORM === 'web') {
                    return h$1('div', { id, className: 'taro_page' }, children);
                }
                else {
                    return h$1('root', { id }, children);
                }
            }
        };
    };
}
/**
 * 桥接小程序 App 构造器和 React 渲染流程
 * @param App 用户编写的入口组件
 * @param react 框架
 * @param dom 框架渲染器
 * @param config 入口组件配置 app.config.js 的内容
 * @returns 传递给 App 构造器的对象 obj ：App(obj)
 */
function createReactApp(App, react, dom, config) {
    if (process.env.NODE_ENV !== 'production') {
        ensure(!!dom, '构建 React/Nerv 项目请把 process.env.FRAMEWORK 设置为 \'react\'/\'preact\'/\'nerv\' ');
    }
    reactMeta.R = react;
    h$1 = react.createElement;
    ReactDOM$1 = dom;
    Fragment = react.Fragment;
    const appInstanceRef = react.createRef();
    const isReactComponent = isClassComponent(react, App);
    let appWrapper;
    let appWrapperResolver;
    const appWrapperPromise = new Promise(resolve => (appWrapperResolver = resolve));
    setReconciler(ReactDOM$1);
    function getAppInstance() {
        return appInstanceRef.current;
    }
    function waitAppWrapper(cb) {
        appWrapper ? cb() : appWrapperPromise.then(() => cb());
    }
    function renderReactRoot() {
        var _a, _b;
        let appId = 'app';
        if (process.env.TARO_PLATFORM === 'web') {
            appId = (config === null || config === void 0 ? void 0 : config.appId) || appId;
        }
        const container = document.getElementById(appId);
        if ((react.version || '').startsWith('18')) {
            const root = ReactDOM$1.createRoot(container);
            (_a = root.render) === null || _a === void 0 ? void 0 : _a.call(root, h$1(AppWrapper));
        }
        else {
            // eslint-disable-next-line react/no-deprecated
            (_b = ReactDOM$1.render) === null || _b === void 0 ? void 0 : _b.call(ReactDOM$1, h$1(AppWrapper), container);
        }
    }
    class AppWrapper extends react.Component {
        constructor(props) {
            super(props);
            // run createElement() inside the render function to make sure that owner is right
            this.pages = [];
            this.elements = [];
            appWrapper = this;
            appWrapperResolver(this);
        }
        mount(pageComponent, id, cb) {
            const pageWrapper = connectReactPage(react, id)(pageComponent);
            const key = id + pageKeyId();
            const page = () => h$1(pageWrapper, { key, tid: id });
            this.pages.push(page);
            this.forceUpdate(cb);
        }
        unmount(id, cb) {
            const elements = this.elements;
            const idx = elements.findIndex(item => item.props.tid === id);
            elements.splice(idx, 1);
            this.forceUpdate(cb);
        }
        render() {
            const { pages, elements } = this;
            while (pages.length > 0) {
                const page = pages.pop();
                elements.push(page());
            }
            let props = null;
            if (isReactComponent) {
                props = { ref: appInstanceRef };
            }
            return h$1(App, props, process.env.TARO_PLATFORM === 'web' ? h$1(Fragment !== null && Fragment !== void 0 ? Fragment : 'div', null, elements.slice()) : elements.slice());
        }
    }
    if (process.env.TARO_PLATFORM !== 'web') {
        renderReactRoot();
    }
    const [ONLAUNCH, ONSHOW, ONHIDE] = hooks.call('getMiniLifecycleImpl').app;
    const appObj = Object.create({
        render(cb) {
            appWrapper.forceUpdate(cb);
        },
        mount(component, id, cb) {
            if (appWrapper) {
                appWrapper.mount(component, id, cb);
            }
            else {
                appWrapperPromise.then(appWrapper => appWrapper.mount(component, id, cb));
            }
        },
        unmount(id, cb) {
            appWrapper.unmount(id, cb);
        }
    }, {
        config: setDefaultDescriptor({
            configurable: true,
            value: config
        }),
        [ONLAUNCH]: setDefaultDescriptor({
            value(options) {
                setRouterParams(options);
                if (process.env.TARO_PLATFORM === 'web') {
                    // 由于 H5 路由初始化的时候会清除 app 下的 dom 元素，所以需要在路由初始化后执行 render
                    renderReactRoot();
                }
                const onLaunch = () => {
                    var _a;
                    // 用户编写的入口组件实例
                    const app = getAppInstance();
                    this.$app = app;
                    if (app) {
                        // 把 App Class 上挂载的额外属性同步到全局 app 对象中
                        if (app.taroGlobalData) {
                            const globalData = app.taroGlobalData;
                            const keys = Object.keys(globalData);
                            const descriptors = Object.getOwnPropertyDescriptors(globalData);
                            keys.forEach(key => {
                                Object.defineProperty(this, key, {
                                    configurable: true,
                                    enumerable: true,
                                    get() {
                                        return globalData[key];
                                    },
                                    set(value) {
                                        globalData[key] = value;
                                    }
                                });
                            });
                            Object.defineProperties(this, descriptors);
                        }
                        (_a = app.onLaunch) === null || _a === void 0 ? void 0 : _a.call(app, options);
                    }
                    triggerAppHook('onLaunch', options);
                };
                waitAppWrapper(onLaunch);
            }
        }),
        [ONSHOW]: setDefaultDescriptor({
            value(options) {
                setRouterParams(options);
                const onShow = () => {
                    var _a;
                    /**
                    * trigger lifecycle
                    */
                    const app = getAppInstance();
                    // class component, componentDidShow
                    (_a = app === null || app === void 0 ? void 0 : app.componentDidShow) === null || _a === void 0 ? void 0 : _a.call(app, options);
                    // functional component, useDidShow
                    triggerAppHook('onShow', options);
                };
                waitAppWrapper(onShow);
            }
        }),
        [ONHIDE]: setDefaultDescriptor({
            value() {
                const onHide = () => {
                    var _a;
                    /**
                     * trigger lifecycle
                     */
                    const app = getAppInstance();
                    // class component, componentDidHide
                    (_a = app === null || app === void 0 ? void 0 : app.componentDidHide) === null || _a === void 0 ? void 0 : _a.call(app);
                    // functional component, useDidHide
                    triggerAppHook('onHide');
                };
                waitAppWrapper(onHide);
            }
        }),
        onError: setDefaultDescriptor({
            value(error) {
                const onError = () => {
                    var _a;
                    const app = getAppInstance();
                    (_a = app === null || app === void 0 ? void 0 : app.onError) === null || _a === void 0 ? void 0 : _a.call(app, error);
                    triggerAppHook('onError', error);
                    if (process.env.NODE_ENV !== 'production' && (error === null || error === void 0 ? void 0 : error.includes('Minified React error'))) {
                        console.warn('React 出现报错，请打开编译配置 mini.debugReact 查看报错详情：https://docs.taro.zone/docs/config-detail#minidebugreact');
                    }
                };
                waitAppWrapper(onError);
            }
        }),
        onUnhandledRejection: setDefaultDescriptor({
            value(res) {
                const onUnhandledRejection = () => {
                    var _a;
                    const app = getAppInstance();
                    (_a = app === null || app === void 0 ? void 0 : app.onUnhandledRejection) === null || _a === void 0 ? void 0 : _a.call(app, res);
                    triggerAppHook('onUnhandledRejection', res);
                };
                waitAppWrapper(onUnhandledRejection);
            }
        }),
        onPageNotFound: setDefaultDescriptor({
            value(res) {
                const onPageNotFound = () => {
                    var _a;
                    const app = getAppInstance();
                    (_a = app === null || app === void 0 ? void 0 : app.onPageNotFound) === null || _a === void 0 ? void 0 : _a.call(app, res);
                    triggerAppHook('onPageNotFound', res);
                };
                waitAppWrapper(onPageNotFound);
            }
        })
    });
    function triggerAppHook(lifecycle, ...option) {
        const instance = getPageInstance(HOOKS_APP_ID);
        if (instance) {
            const app = getAppInstance();
            const func = hooks.call('getLifecycle', instance, lifecycle);
            if (Array.isArray(func)) {
                func.forEach(cb => cb.apply(app, option));
            }
        }
    }
    Current.app = appObj;
    return appObj;
}

const getNativeCompId = incrementId();
let h;
let ReactDOM;
let nativeComponentApp;
function initNativeComponentEntry(params) {
    var _a;
    const { R, ReactDOM, cb, isDefaultEntryDom = true } = params;
    class NativeComponentWrapper extends R.Component {
        constructor() {
            super(...arguments);
            this.root = R.createRef();
            this.ctx = this.props.getCtx();
        }
        componentDidMount() {
            this.ctx.component = this;
            const rootElement = this.root.current;
            rootElement.ctx = this.ctx;
            rootElement.performUpdate(true);
        }
        render() {
            return (h('root', {
                ref: this.root,
                id: this.props.compId
            }, this.props.renderComponent(this.ctx)));
        }
    }
    class Entry extends R.Component {
        constructor() {
            super(...arguments);
            this.state = {
                components: []
            };
        }
        componentDidMount() {
            if (isDefaultEntryDom) {
                Current.app = this;
            }
            else {
                nativeComponentApp = this;
            }
            cb && cb();
        }
        mount(Component, compId, getCtx, cb) {
            const isReactComponent = isClassComponent(R, Component);
            const inject = (node) => node && injectPageInstance(node, compId);
            const refs = isReactComponent ? { ref: inject } : {
                forwardedRef: inject,
                reactReduxForwardedRef: inject
            };
            if (reactMeta.PageContext === EMPTY_OBJ) {
                reactMeta.PageContext = R.createContext('');
            }
            const item = {
                compId,
                element: h(NativeComponentWrapper, {
                    key: compId,
                    compId,
                    getCtx,
                    renderComponent(ctx) {
                        return h(reactMeta.PageContext.Provider, { value: compId }, h(Component, Object.assign(Object.assign(Object.assign({}, (ctx.data || (ctx.data = {})).props), refs), { $scope: ctx })));
                    }
                })
            };
            this.setState({
                components: [...this.state.components, item]
            }, () => cb && cb());
        }
        unmount(compId, cb) {
            const components = this.state.components;
            const index = components.findIndex(item => item.compId === compId);
            const next = [...components.slice(0, index), ...components.slice(index + 1)];
            this.setState({
                components: next
            }, () => {
                removePageInstance(compId);
                cb && cb();
            });
        }
        render() {
            const components = this.state.components;
            return (components.map(({ element }) => element));
        }
    }
    setReconciler(ReactDOM);
    let app = document.getElementById('app');
    if (!isDefaultEntryDom && !nativeComponentApp) {
        // create
        const nativeApp = document.createElement('nativeComponent');
        // insert
        (_a = app === null || app === void 0 ? void 0 : app.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(nativeApp);
        app = nativeApp;
    }
    ReactDOM.render(h(Entry, {}), app);
}
function createNativePageConfig(Component, pageName, data, react, reactdom, pageConfig) {
    reactMeta.R = react;
    h = react.createElement;
    ReactDOM = reactdom;
    setReconciler(ReactDOM);
    const [ONLOAD, ONUNLOAD, ONREADY, ONSHOW, ONHIDE, LIFECYCLES, SIDE_EFFECT_LIFECYCLES] = hooks.call('getMiniLifecycleImpl').page;
    let unmounting = false;
    let prepareMountList = [];
    let pageElement = null;
    let loadResolver;
    let hasLoaded;
    const id = pageName !== null && pageName !== void 0 ? pageName : `taro_page_${getNativeCompId()}`;
    function setCurrentRouter(page) {
        const router = page.route || page.__route__ || page.$taroPath;
        Current.router = {
            params: page.$taroParams,
            path: addLeadingSlash(router),
            $taroPath: page.$taroPath,
            onReady: getOnReadyEventKey(id),
            onShow: getOnShowEventKey(id),
            onHide: getOnHideEventKey(id)
        };
        if (!isUndefined(page.exitState)) {
            Current.router.exitState = page.exitState;
        }
    }
    const pageObj = {
        options: pageConfig,
        [ONLOAD](options = {}, cb) {
            hasLoaded = new Promise(resolve => { loadResolver = resolve; });
            Current.page = this;
            this.config = pageConfig || {};
            // this.$taroPath 是页面唯一标识
            const uniqueOptions = Object.assign({}, options, { $taroTimestamp: Date.now() });
            const $taroPath = this.$taroPath = getPath(id, uniqueOptions);
            // this.$taroParams 作为暴露给开发者的页面参数对象，可以被随意修改
            if (this.$taroParams == null) {
                this.$taroParams = uniqueOptions;
            }
            setCurrentRouter(this);
            window.trigger(CONTEXT_ACTIONS.INIT, $taroPath);
            const mountCallback = () => {
                pageElement = document.getElementById($taroPath);
                ensure(pageElement !== null, '没有找到页面实例。');
                safeExecute($taroPath, ONLOAD, this.$taroParams);
                loadResolver();
                pageElement.ctx = this;
                pageElement.performUpdate(true, cb);
            };
            const mount = () => {
                if (!Current.app) {
                    initNativeComponentEntry({
                        R: react,
                        ReactDOM,
                        cb: () => {
                            Current.app.mount(Component, $taroPath, () => this, mountCallback);
                        }
                    });
                }
                else {
                    Current.app.mount(Component, $taroPath, () => this, mountCallback);
                }
            };
            if (unmounting) {
                prepareMountList.push(mount);
            }
            else {
                mount();
            }
        },
        [ONUNLOAD]() {
            const $taroPath = this.$taroPath;
            // 销毁当前页面的上下文信息
            window.trigger(CONTEXT_ACTIONS.DESTORY, $taroPath);
            // 触发onUnload生命周期
            safeExecute($taroPath, ONUNLOAD);
            resetCurrent();
            unmounting = true;
            Current.app.unmount($taroPath, () => {
                unmounting = false;
                removePageInstance($taroPath);
                if (pageElement) {
                    pageElement.ctx = null;
                    pageElement = null;
                }
                if (prepareMountList.length) {
                    prepareMountList.forEach(fn => fn());
                    prepareMountList = [];
                }
            });
        },
        [ONREADY]() {
            hasLoaded.then(() => {
                // 触发生命周期
                safeExecute(this.$taroPath, ON_READY);
                // 通过事件触发子组件的生命周期
                requestAnimationFrame(() => eventCenter.trigger(getOnReadyEventKey(id)));
                this.onReady.called = true;
            });
        },
        [ONSHOW](options = {}) {
            hasLoaded.then(() => {
                // 设置 Current 的 page 和 router
                Current.page = this;
                setCurrentRouter(this);
                // 恢复上下文信息
                window.trigger(CONTEXT_ACTIONS.RECOVER, this.$taroPath);
                // 触发生命周期
                safeExecute(this.$taroPath, ON_SHOW, options);
                // 通过事件触发子组件的生命周期
                requestAnimationFrame(() => eventCenter.trigger(getOnShowEventKey(id)));
            });
        },
        [ONHIDE]() {
            // 缓存当前页面上下文信息
            window.trigger(CONTEXT_ACTIONS.RESTORE, this.$taroPath);
            // 设置 Current 的 page 和 router
            if (Current.page === this) {
                Current.page = null;
                Current.router = null;
            }
            // 触发生命周期
            safeExecute(this.$taroPath, ON_HIDE);
            // 通过事件触发子组件的生命周期
            eventCenter.trigger(getOnHideEventKey(id));
        },
    };
    function resetCurrent() {
        // 小程序插件页面卸载之后返回到宿主页面时，需重置Current页面和路由。否则引发插件组件二次加载异常 fix:#11991
        Current.page = null;
        Current.router = null;
    }
    LIFECYCLES.forEach((lifecycle) => {
        pageObj[lifecycle] = function () {
            return safeExecute(this.$taroPath, lifecycle, ...arguments);
        };
    });
    // onShareAppMessage 和 onShareTimeline 一样，会影响小程序右上方按钮的选项，因此不能默认注册。
    SIDE_EFFECT_LIFECYCLES.forEach(lifecycle => {
        var _a;
        if (Component[lifecycle] ||
            ((_a = Component.prototype) === null || _a === void 0 ? void 0 : _a[lifecycle]) ||
            Component[lifecycle.replace(/^on/, 'enable')]) {
            pageObj[lifecycle] = function (...args) {
                var _a;
                const target = (_a = args[0]) === null || _a === void 0 ? void 0 : _a.target;
                if (target === null || target === void 0 ? void 0 : target.id) {
                    const id = target.id;
                    const element = document.getElementById(id);
                    if (element) {
                        target.dataset = element.dataset;
                    }
                }
                return safeExecute(this.$taroPath, lifecycle, ...args);
            };
        }
    });
    pageObj.eh = eventHandler;
    if (!isUndefined(data)) {
        pageObj.data = data;
    }
    hooks.call('modifyPageObject', pageObj);
    return pageObj;
}
function createH5NativeComponentConfig(Component, react, reactdom) {
    reactMeta.R = react;
    h = react.createElement;
    ReactDOM = reactdom;
    setReconciler(ReactDOM);
    return Component;
}
function createNativeComponentConfig(Component, react, reactdom, componentConfig) {
    var _a, _b;
    reactMeta.R = react;
    h = react.createElement;
    ReactDOM = reactdom;
    setReconciler(ReactDOM);
    const { isNewBlended } = componentConfig;
    const componentObj = {
        options: componentConfig,
        properties: {
            props: {
                type: null,
                value: null,
                observer(_newVal, oldVal) {
                    var _a;
                    oldVal && ((_a = this.component) === null || _a === void 0 ? void 0 : _a.forceUpdate());
                }
            }
        },
        created() {
            const app = (isNewBlended ? nativeComponentApp : Current.app);
            if (!app) {
                initNativeComponentEntry({
                    R: react,
                    ReactDOM,
                    isDefaultEntryDom: !isNewBlended
                });
            }
        },
        attached() {
            const compId = this.compId = getNativeCompId();
            setCurrent(compId);
            this.config = componentConfig;
            const app = (isNewBlended ? nativeComponentApp : Current.app);
            app.mount(Component, compId, () => this, () => {
                const instance = getPageInstance(compId);
                if (instance && instance.node) {
                    const el = document.getElementById(instance.node.uid);
                    if (el) {
                        el.ctx = this;
                    }
                }
            });
        },
        ready() {
            safeExecute(this.compId, 'onReady');
        },
        detached() {
            resetCurrent();
            const app = (isNewBlended ? nativeComponentApp : Current.app);
            app.unmount(this.compId);
        },
        pageLifetimes: {
            show(options) {
                safeExecute(this.compId, 'onShow', options);
            },
            hide() {
                safeExecute(this.compId, 'onHide');
            }
        },
        methods: {
            eh: eventHandler,
            onLoad(options) {
                safeExecute(this.compId, 'onLoad', options);
            },
            onUnload() {
                safeExecute(this.compId, 'onUnload');
            }
        }
    };
    function resetCurrent() {
        // 小程序插件页面卸载之后返回到宿主页面时，需重置Current页面和路由。否则引发插件组件二次加载异常 fix:#11991
        Current.page = null;
        Current.router = null;
    }
    // onShareAppMessage 和 onShareTimeline 一样，会影响小程序右上方按钮的选项，因此不能默认注册。
    if (Component.onShareAppMessage ||
        ((_a = Component.prototype) === null || _a === void 0 ? void 0 : _a.onShareAppMessage) ||
        Component.enableShareAppMessage) {
        componentObj.methods.onShareAppMessage = function (options) {
            const target = options === null || options === void 0 ? void 0 : options.target;
            if (target) {
                const id = target.id;
                const element = document.getElementById(id);
                if (element) {
                    target.dataset = element.dataset;
                }
            }
            return safeExecute(this.compId, 'onShareAppMessage', options);
        };
    }
    if (Component.onShareTimeline ||
        ((_b = Component.prototype) === null || _b === void 0 ? void 0 : _b.onShareTimeline) ||
        Component.enableShareTimeline) {
        componentObj.methods.onShareTimeline = function () {
            return safeExecute(this.compId, 'onShareTimeline');
        };
    }
    return componentObj;
}
function setCurrent(compId) {
    if (!getCurrentPages || typeof getCurrentPages !== 'function')
        return;
    const pages = getCurrentPages();
    const currentPage = pages[pages.length - 1];
    if (Current.page === currentPage)
        return;
    Current.page = currentPage;
    const route = currentPage.route || currentPage.__route__;
    const router = {
        params: currentPage.options || {},
        path: addLeadingSlash(route),
        $taroPath: compId,
        onReady: '',
        onHide: '',
        onShow: ''
    };
    Current.router = router;
    if (!currentPage.options) {
        // 例如在微信小程序中，页面 options 的设置时机比组件 attached 慢
        Object.defineProperty(currentPage, 'options', {
            enumerable: true,
            configurable: true,
            get() {
                return this._optionsValue;
            },
            set(value) {
                router.params = value;
                this._optionsValue = value;
            }
        });
    }
}

hooks.tap('initNativeApi', function (taro) {
    for (const hook in taroHooks) {
        taro[hook] = taroHooks[hook];
    }
});
if (__TARO_FRAMEWORK__ === 'preact') {
    const options = require('preact').options;
    const oldVNodeHook = options.vnode;
    const oldDiffedHook = options.diffed;
    options.vnode = vnode => {
        const { type, props } = vnode;
        let normalizedProps = props;
        // only normalize props on Element nodes
        if (typeof type === 'string') {
            normalizedProps = {};
            for (let i in props) {
                const value = props[i];
                if (/^on/.test(i)) {
                    i = i.toLowerCase();
                }
                if (type === 'map' && i === 'onregionchange') {
                    // map 组件的 regionchange 事件非常特殊，详情：https://github.com/NervJS/taro/issues/5766
                    normalizedProps.onbegin = value;
                    normalizedProps.onend = value;
                    continue;
                }
                normalizedProps[i] = value;
            }
            vnode.props = normalizedProps;
        }
        if (oldVNodeHook)
            oldVNodeHook(vnode);
    };
    options.diffed = function (newVNode) {
        var _a;
        const domProp = Object.keys(newVNode).find(k => { var _a; return ((_a = newVNode[k]) === null || _a === void 0 ? void 0 : _a.setAttribute); });
        const dom = domProp ? newVNode[domProp] : null;
        const newVNodeProps = newVNode.props;
        if (dom) { /** ElementNode */
            for (const propName in newVNodeProps) {
                const propValue = newVNodeProps[propName];
                if (propValue === false && ((_a = dom.props) === null || _a === void 0 ? void 0 : _a[propName]) === undefined) {
                    // 值为 false 的属性在 Preact 的 diff 中被 removeAttribute 了，这里手动 setAttribute
                    // fix https://github.com/NervJS/taro/issues/11197
                    dom.setAttribute(propName, propValue);
                }
            }
        }
        if (oldDiffedHook)
            oldDiffedHook(newVNode);
    };
    hooks.tap('modifyMpEvent', e => {
        const type = e.type;
        if (type === 'tap') {
            e.type = 'click';
        }
        else if (type === 'focus') {
            // 兼容 preact/compat/src/render.js options.vnode 的处理逻辑
            e.type = 'focusin';
        }
        else if (type === 'blur') {
            e.type = 'focusout';
        }
    });
    // hooks.modifyDispatchEventImpls?.push(e => {
    // })
}

export { connectReactPage, createH5NativeComponentConfig, createNativeComponentConfig, createNativePageConfig, createReactApp, setReconciler, useAddToFavorites, useDidHide, useDidShow, useError, useLaunch, useLoad, useOptionMenuClick, usePageNotFound, usePageScroll, usePullDownRefresh, usePullIntercept, useReachBottom, useReady, useResize, useRouter, useSaveExitState, useScope, useShareAppMessage, useShareTimeline, useTabItemTap, useTitleClick, useUnhandledRejection, useUnload };
//# sourceMappingURL=runtime.js.map
