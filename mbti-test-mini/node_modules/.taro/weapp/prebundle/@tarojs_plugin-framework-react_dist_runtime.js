import { CONTEXT_ACTIONS, Current, ON_HIDE, ON_READY, ON_SHOW, _raf, addLeadingSlash, document$1, eventCenter, eventHandler, getOnHideEventKey, getOnReadyEventKey, getOnShowEventKey, getPageInstance, getPath, incrementId, init_runtime_esm, injectPageInstance, removePageInstance, safeExecute, window$1 } from "./chunk-NB3SMQAD.js";
import { EMPTY_OBJ, ensure, hooks, init_shared_esm, isArray, isFunction, isUndefined } from "./chunk-IVCJO3ZX.js";
import "./chunk-3RWA6CQF.js";
// node_modules/@tarojs/plugin-framework-react/dist/runtime.js
init_shared_esm();
init_runtime_esm();
var reactMeta = {
    PageContext: EMPTY_OBJ,
    R: EMPTY_OBJ
};
var HOOKS_APP_ID = "taro-app";
function isClassComponent(R, component) {
    var _a;
    const prototype = component.prototype;
    if ((_a = component.displayName) === null || _a === void 0 ? void 0 : _a.includes("Connect")) return false;
    return isFunction(component.render) || !!(prototype === null || prototype === void 0 ? void 0 : prototype.isReactComponent) || prototype instanceof R.Component;
}
function ensureIsArray(item) {
    if (isArray(item)) {
        return item;
    } else {
        return item ? [
            item
        ] : [];
    }
}
function setDefaultDescriptor(obj) {
    obj.writable = true;
    obj.enumerable = true;
    return obj;
}
function setRouterParams(options) {
    Current.router = Object.assign({
        params: options === null || options === void 0 ? void 0 : options.query
    }, options);
}
var createTaroHook = (lifecycle)=>{
    return (fn)=>{
        const { R: React, PageContext } = reactMeta;
        const id = React.useContext(PageContext) || HOOKS_APP_ID;
        const instRef = React.useRef();
        const fnRef = React.useRef(fn);
        if (fnRef.current !== fn) fnRef.current = fn;
        React.useLayoutEffect(()=>{
            let inst = instRef.current = getPageInstance(id);
            let first = false;
            if (!inst) {
                first = true;
                instRef.current = /* @__PURE__ */ Object.create(null);
                inst = instRef.current;
            }
            const callback = (...args)=>fnRef.current(...args);
            if (isFunction(inst[lifecycle])) {
                inst[lifecycle] = [
                    inst[lifecycle],
                    callback
                ];
            } else {
                inst[lifecycle] = [
                    ...inst[lifecycle] || [],
                    callback
                ];
            }
            if (first) {
                injectPageInstance(inst, id);
            }
            return ()=>{
                const inst2 = instRef.current;
                if (!inst2) return;
                const list = inst2[lifecycle];
                if (list === callback) {
                    inst2[lifecycle] = void 0;
                } else if (isArray(list)) {
                    inst2[lifecycle] = list.filter((item)=>item !== callback);
                }
                instRef.current = void 0;
            };
        }, []);
    };
};
var useDidHide = createTaroHook("componentDidHide");
var useDidShow = createTaroHook("componentDidShow");
var useError = createTaroHook("onError");
var useUnhandledRejection = createTaroHook("onUnhandledRejection");
var useLaunch = createTaroHook("onLaunch");
var usePageNotFound = createTaroHook("onPageNotFound");
var useLoad = createTaroHook("onLoad");
var usePageScroll = createTaroHook("onPageScroll");
var usePullDownRefresh = createTaroHook("onPullDownRefresh");
var usePullIntercept = createTaroHook("onPullIntercept");
var useReachBottom = createTaroHook("onReachBottom");
var useResize = createTaroHook("onResize");
var useUnload = createTaroHook("onUnload");
var useAddToFavorites = createTaroHook("onAddToFavorites");
var useOptionMenuClick = createTaroHook("onOptionMenuClick");
var useSaveExitState = createTaroHook("onSaveExitState");
var useShareAppMessage = createTaroHook("onShareAppMessage");
var useShareTimeline = createTaroHook("onShareTimeline");
var useTitleClick = createTaroHook("onTitleClick");
var useReady = createTaroHook("onReady");
var useRouter = (dynamic = false)=>{
    const React = reactMeta.R;
    return dynamic ? Current.router : React.useMemo(()=>Current.router, []);
};
var useTabItemTap = createTaroHook("onTabItemTap");
var useScope = ()=>void 0;
var taroHooks = Object.freeze({
    __proto__: null,
    useAddToFavorites,
    useDidHide,
    useDidShow,
    useError,
    useLaunch,
    useLoad,
    useOptionMenuClick,
    usePageNotFound,
    usePageScroll,
    usePullDownRefresh,
    usePullIntercept,
    useReachBottom,
    useReady,
    useResize,
    useRouter,
    useSaveExitState,
    useScope,
    useShareAppMessage,
    useShareTimeline,
    useTabItemTap,
    useTitleClick,
    useUnhandledRejection,
    useUnload
});
var h$1;
var ReactDOM$1;
var Fragment;
var pageKeyId = incrementId();
function setReconciler(ReactDOM2) {
    hooks.tap("getLifecycle", function(instance, lifecycle) {
        lifecycle = lifecycle.replace(/^on(Show|Hide)$/, "componentDid$1");
        return instance[lifecycle];
    });
    hooks.tap("modifyMpEvent", function(event) {
        Object.defineProperty(event, "type", {
            value: event.type.replace(/-/g, "")
        });
    });
    hooks.tap("batchedEventUpdates", function(cb) {
        ReactDOM2.unstable_batchedUpdates(cb);
    });
    hooks.tap("mergePageInstance", function(prev, next) {
        if (!prev || !next) return;
        if ("constructor" in prev) return;
        Object.keys(prev).forEach((item)=>{
            const prevList = prev[item];
            const nextList = ensureIsArray(next[item]);
            next[item] = nextList.concat(prevList);
        });
    });
    if (false) {
        hooks.tap("createPullDownComponent", (el, _, R, customWrapper)=>{
            const isReactComponent = isClassComponent(R, el);
            return R.forwardRef((props, ref)=>{
                const newProps = Object.assign({}, props);
                const refs = isReactComponent ? {
                    ref
                } : {
                    forwardedRef: ref,
                    // 兼容 react-redux 7.20.1+
                    reactReduxForwardedRef: ref
                };
                return h$1(customWrapper || "taro-pull-to-refresh-core", null, h$1(el, Object.assign(Object.assign({}, newProps), refs)));
            });
        });
        hooks.tap("getDOMNode", (inst)=>{
            if (!inst) {
                return document$1;
            } else if (inst instanceof HTMLElement) {
                return inst;
            } else if (inst.$taroPath) {
                const el = document$1.getElementById(inst.$taroPath);
                return el !== null && el !== void 0 ? el : document$1;
            }
        });
    }
}
function connectReactPage(R, id) {
    return (Page)=>{
        const isReactComponent = isClassComponent(R, Page);
        const inject = (node)=>node && injectPageInstance(node, id);
        const refs = isReactComponent ? {
            ref: inject
        } : {
            forwardedRef: inject,
            // 兼容 react-redux 7.20.1+
            reactReduxForwardedRef: inject
        };
        if (reactMeta.PageContext === EMPTY_OBJ) {
            reactMeta.PageContext = R.createContext("");
        }
        return class PageWrapper extends R.Component {
            static getDerivedStateFromError(error) {
                var _a, _b;
                (_b = (_a = Current.app) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, error.message + error.stack);
                return {
                    hasError: true
                };
            }
            // React 16 uncaught error 会导致整个应用 crash，
            // 目前把错误缩小到页面
            componentDidCatch(error, info) {
                if (true) {
                    console.warn(error);
                    console.error(info.componentStack);
                }
            }
            render() {
                const children = this.state.hasError ? [] : h$1(reactMeta.PageContext.Provider, {
                    value: id
                }, h$1(Page, Object.assign(Object.assign({}, this.props), refs)));
                if (false) {
                    return h$1("div", {
                        id,
                        className: "taro_page"
                    }, children);
                } else {
                    return h$1("root", {
                        id
                    }, children);
                }
            }
            constructor(){
                super(...arguments);
                this.state = {
                    hasError: false
                };
            }
        };
    };
}
function createReactApp(App, react, dom, config) {
    if (true) {
        ensure(!!dom, "\u6784\u5EFA React/Nerv \u9879\u76EE\u8BF7\u628A process.env.FRAMEWORK \u8BBE\u7F6E\u4E3A 'react'/'preact'/'nerv' ");
    }
    reactMeta.R = react;
    h$1 = react.createElement;
    ReactDOM$1 = dom;
    Fragment = react.Fragment;
    const appInstanceRef = react.createRef();
    const isReactComponent = isClassComponent(react, App);
    let appWrapper;
    let appWrapperResolver;
    const appWrapperPromise = new Promise((resolve)=>appWrapperResolver = resolve);
    setReconciler(ReactDOM$1);
    function getAppInstance() {
        return appInstanceRef.current;
    }
    function waitAppWrapper(cb) {
        appWrapper ? cb() : appWrapperPromise.then(()=>cb());
    }
    function renderReactRoot() {
        var _a, _b;
        let appId = "app";
        if (false) {
            appId = (config === null || config === void 0 ? void 0 : config.appId) || appId;
        }
        const container = document$1.getElementById(appId);
        if ((react.version || "").startsWith("18")) {
            const root = ReactDOM$1.createRoot(container);
            (_a = root.render) === null || _a === void 0 ? void 0 : _a.call(root, h$1(AppWrapper));
        } else {
            (_b = ReactDOM$1.render) === null || _b === void 0 ? void 0 : _b.call(ReactDOM$1, h$1(AppWrapper), container);
        }
    }
    class AppWrapper extends react.Component {
        mount(pageComponent, id, cb) {
            const pageWrapper = connectReactPage(react, id)(pageComponent);
            const key = id + pageKeyId();
            const page = ()=>h$1(pageWrapper, {
                    key,
                    tid: id
                });
            this.pages.push(page);
            this.forceUpdate(cb);
        }
        unmount(id, cb) {
            const elements = this.elements;
            const idx = elements.findIndex((item)=>item.props.tid === id);
            elements.splice(idx, 1);
            this.forceUpdate(cb);
        }
        render() {
            const { pages, elements } = this;
            while(pages.length > 0){
                const page = pages.pop();
                elements.push(page());
            }
            let props = null;
            if (isReactComponent) {
                props = {
                    ref: appInstanceRef
                };
            }
            return h$1(App, props, false ? h$1(Fragment !== null && Fragment !== void 0 ? Fragment : "div", null, elements.slice()) : elements.slice());
        }
        constructor(props){
            super(props);
            this.pages = [];
            this.elements = [];
            appWrapper = this;
            appWrapperResolver(this);
        }
    }
    if (true) {
        renderReactRoot();
    }
    const [ONLAUNCH, ONSHOW, ONHIDE] = hooks.call("getMiniLifecycleImpl").app;
    const appObj = Object.create({
        render (cb) {
            appWrapper.forceUpdate(cb);
        },
        mount (component, id, cb) {
            if (appWrapper) {
                appWrapper.mount(component, id, cb);
            } else {
                appWrapperPromise.then((appWrapper2)=>appWrapper2.mount(component, id, cb));
            }
        },
        unmount (id, cb) {
            appWrapper.unmount(id, cb);
        }
    }, {
        config: setDefaultDescriptor({
            configurable: true,
            value: config
        }),
        [ONLAUNCH]: setDefaultDescriptor({
            value (options) {
                setRouterParams(options);
                if (false) {
                    renderReactRoot();
                }
                const onLaunch = ()=>{
                    var _a;
                    const app = getAppInstance();
                    this.$app = app;
                    if (app) {
                        if (app.taroGlobalData) {
                            const globalData = app.taroGlobalData;
                            const keys = Object.keys(globalData);
                            const descriptors = Object.getOwnPropertyDescriptors(globalData);
                            keys.forEach((key)=>{
                                Object.defineProperty(this, key, {
                                    configurable: true,
                                    enumerable: true,
                                    get () {
                                        return globalData[key];
                                    },
                                    set (value) {
                                        globalData[key] = value;
                                    }
                                });
                            });
                            Object.defineProperties(this, descriptors);
                        }
                        (_a = app.onLaunch) === null || _a === void 0 ? void 0 : _a.call(app, options);
                    }
                    triggerAppHook("onLaunch", options);
                };
                waitAppWrapper(onLaunch);
            }
        }),
        [ONSHOW]: setDefaultDescriptor({
            value (options) {
                setRouterParams(options);
                const onShow = ()=>{
                    var _a;
                    const app = getAppInstance();
                    (_a = app === null || app === void 0 ? void 0 : app.componentDidShow) === null || _a === void 0 ? void 0 : _a.call(app, options);
                    triggerAppHook("onShow", options);
                };
                waitAppWrapper(onShow);
            }
        }),
        [ONHIDE]: setDefaultDescriptor({
            value () {
                const onHide = ()=>{
                    var _a;
                    const app = getAppInstance();
                    (_a = app === null || app === void 0 ? void 0 : app.componentDidHide) === null || _a === void 0 ? void 0 : _a.call(app);
                    triggerAppHook("onHide");
                };
                waitAppWrapper(onHide);
            }
        }),
        onError: setDefaultDescriptor({
            value (error) {
                const onError = ()=>{
                    var _a;
                    const app = getAppInstance();
                    (_a = app === null || app === void 0 ? void 0 : app.onError) === null || _a === void 0 ? void 0 : _a.call(app, error);
                    triggerAppHook("onError", error);
                    if (error === null || error === void 0 ? void 0 : error.includes("Minified React error")) {
                        console.warn("React \u51FA\u73B0\u62A5\u9519\uFF0C\u8BF7\u6253\u5F00\u7F16\u8BD1\u914D\u7F6E mini.debugReact \u67E5\u770B\u62A5\u9519\u8BE6\u60C5\uFF1Ahttps://docs.taro.zone/docs/config-detail#minidebugreact");
                    }
                };
                waitAppWrapper(onError);
            }
        }),
        onUnhandledRejection: setDefaultDescriptor({
            value (res) {
                const onUnhandledRejection = ()=>{
                    var _a;
                    const app = getAppInstance();
                    (_a = app === null || app === void 0 ? void 0 : app.onUnhandledRejection) === null || _a === void 0 ? void 0 : _a.call(app, res);
                    triggerAppHook("onUnhandledRejection", res);
                };
                waitAppWrapper(onUnhandledRejection);
            }
        }),
        onPageNotFound: setDefaultDescriptor({
            value (res) {
                const onPageNotFound = ()=>{
                    var _a;
                    const app = getAppInstance();
                    (_a = app === null || app === void 0 ? void 0 : app.onPageNotFound) === null || _a === void 0 ? void 0 : _a.call(app, res);
                    triggerAppHook("onPageNotFound", res);
                };
                waitAppWrapper(onPageNotFound);
            }
        })
    });
    function triggerAppHook(lifecycle, ...option) {
        const instance = getPageInstance(HOOKS_APP_ID);
        if (instance) {
            const app = getAppInstance();
            const func = hooks.call("getLifecycle", instance, lifecycle);
            if (Array.isArray(func)) {
                func.forEach((cb)=>cb.apply(app, option));
            }
        }
    }
    Current.app = appObj;
    return appObj;
}
var getNativeCompId = incrementId();
var h;
var ReactDOM;
var nativeComponentApp;
function initNativeComponentEntry(params) {
    var _a;
    const { R, ReactDOM: ReactDOM2, cb, isDefaultEntryDom = true } = params;
    class NativeComponentWrapper extends R.Component {
        componentDidMount() {
            this.ctx.component = this;
            const rootElement = this.root.current;
            rootElement.ctx = this.ctx;
            rootElement.performUpdate(true);
        }
        render() {
            return h("root", {
                ref: this.root,
                id: this.props.compId
            }, this.props.renderComponent(this.ctx));
        }
        constructor(){
            super(...arguments);
            this.root = R.createRef();
            this.ctx = this.props.getCtx();
        }
    }
    class Entry extends R.Component {
        componentDidMount() {
            if (isDefaultEntryDom) {
                Current.app = this;
            } else {
                nativeComponentApp = this;
            }
            cb && cb();
        }
        mount(Component, compId, getCtx, cb2) {
            const isReactComponent = isClassComponent(R, Component);
            const inject = (node)=>node && injectPageInstance(node, compId);
            const refs = isReactComponent ? {
                ref: inject
            } : {
                forwardedRef: inject,
                reactReduxForwardedRef: inject
            };
            if (reactMeta.PageContext === EMPTY_OBJ) {
                reactMeta.PageContext = R.createContext("");
            }
            const item = {
                compId,
                element: h(NativeComponentWrapper, {
                    key: compId,
                    compId,
                    getCtx,
                    renderComponent (ctx) {
                        return h(reactMeta.PageContext.Provider, {
                            value: compId
                        }, h(Component, Object.assign(Object.assign(Object.assign({}, (ctx.data || (ctx.data = {})).props), refs), {
                            $scope: ctx
                        })));
                    }
                })
            };
            this.setState({
                components: [
                    ...this.state.components,
                    item
                ]
            }, ()=>cb2 && cb2());
        }
        unmount(compId, cb2) {
            const components = this.state.components;
            const index = components.findIndex((item)=>item.compId === compId);
            const next = [
                ...components.slice(0, index),
                ...components.slice(index + 1)
            ];
            this.setState({
                components: next
            }, ()=>{
                removePageInstance(compId);
                cb2 && cb2();
            });
        }
        render() {
            const components = this.state.components;
            return components.map(({ element })=>element);
        }
        constructor(){
            super(...arguments);
            this.state = {
                components: []
            };
        }
    }
    setReconciler(ReactDOM2);
    let app = document$1.getElementById("app");
    if (!isDefaultEntryDom && !nativeComponentApp) {
        const nativeApp = document$1.createElement("nativeComponent");
        (_a = app === null || app === void 0 ? void 0 : app.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(nativeApp);
        app = nativeApp;
    }
    ReactDOM2.render(h(Entry, {}), app);
}
function createNativePageConfig(Component, pageName, data, react, reactdom, pageConfig) {
    reactMeta.R = react;
    h = react.createElement;
    ReactDOM = reactdom;
    setReconciler(ReactDOM);
    const [ONLOAD, ONUNLOAD, ONREADY, ONSHOW, ONHIDE, LIFECYCLES, SIDE_EFFECT_LIFECYCLES] = hooks.call("getMiniLifecycleImpl").page;
    let unmounting = false;
    let prepareMountList = [];
    let pageElement = null;
    let loadResolver;
    let hasLoaded;
    const id = pageName !== null && pageName !== void 0 ? pageName : `taro_page_${getNativeCompId()}`;
    function setCurrentRouter(page) {
        const router = page.route || page.__route__ || page.$taroPath;
        Current.router = {
            params: page.$taroParams,
            path: addLeadingSlash(router),
            $taroPath: page.$taroPath,
            onReady: getOnReadyEventKey(id),
            onShow: getOnShowEventKey(id),
            onHide: getOnHideEventKey(id)
        };
        if (!isUndefined(page.exitState)) {
            Current.router.exitState = page.exitState;
        }
    }
    const pageObj = {
        options: pageConfig,
        [ONLOAD] (options = {}, cb) {
            hasLoaded = new Promise((resolve)=>{
                loadResolver = resolve;
            });
            Current.page = this;
            this.config = pageConfig || {};
            const uniqueOptions = Object.assign({}, options, {
                $taroTimestamp: Date.now()
            });
            const $taroPath = this.$taroPath = getPath(id, uniqueOptions);
            if (this.$taroParams == null) {
                this.$taroParams = uniqueOptions;
            }
            setCurrentRouter(this);
            window$1.trigger(CONTEXT_ACTIONS.INIT, $taroPath);
            const mountCallback = ()=>{
                pageElement = document$1.getElementById($taroPath);
                ensure(pageElement !== null, "\u6CA1\u6709\u627E\u5230\u9875\u9762\u5B9E\u4F8B\u3002");
                safeExecute($taroPath, ONLOAD, this.$taroParams);
                loadResolver();
                pageElement.ctx = this;
                pageElement.performUpdate(true, cb);
            };
            const mount = ()=>{
                if (!Current.app) {
                    initNativeComponentEntry({
                        R: react,
                        ReactDOM,
                        cb: ()=>{
                            Current.app.mount(Component, $taroPath, ()=>this, mountCallback);
                        }
                    });
                } else {
                    Current.app.mount(Component, $taroPath, ()=>this, mountCallback);
                }
            };
            if (unmounting) {
                prepareMountList.push(mount);
            } else {
                mount();
            }
        },
        [ONUNLOAD] () {
            const $taroPath = this.$taroPath;
            window$1.trigger(CONTEXT_ACTIONS.DESTORY, $taroPath);
            safeExecute($taroPath, ONUNLOAD);
            resetCurrent();
            unmounting = true;
            Current.app.unmount($taroPath, ()=>{
                unmounting = false;
                removePageInstance($taroPath);
                if (pageElement) {
                    pageElement.ctx = null;
                    pageElement = null;
                }
                if (prepareMountList.length) {
                    prepareMountList.forEach((fn)=>fn());
                    prepareMountList = [];
                }
            });
        },
        [ONREADY] () {
            hasLoaded.then(()=>{
                safeExecute(this.$taroPath, ON_READY);
                _raf(()=>eventCenter.trigger(getOnReadyEventKey(id)));
                this.onReady.called = true;
            });
        },
        [ONSHOW] (options = {}) {
            hasLoaded.then(()=>{
                Current.page = this;
                setCurrentRouter(this);
                window$1.trigger(CONTEXT_ACTIONS.RECOVER, this.$taroPath);
                safeExecute(this.$taroPath, ON_SHOW, options);
                _raf(()=>eventCenter.trigger(getOnShowEventKey(id)));
            });
        },
        [ONHIDE] () {
            window$1.trigger(CONTEXT_ACTIONS.RESTORE, this.$taroPath);
            if (Current.page === this) {
                Current.page = null;
                Current.router = null;
            }
            safeExecute(this.$taroPath, ON_HIDE);
            eventCenter.trigger(getOnHideEventKey(id));
        }
    };
    function resetCurrent() {
        Current.page = null;
        Current.router = null;
    }
    LIFECYCLES.forEach((lifecycle)=>{
        pageObj[lifecycle] = function() {
            return safeExecute(this.$taroPath, lifecycle, ...arguments);
        };
    });
    SIDE_EFFECT_LIFECYCLES.forEach((lifecycle)=>{
        var _a;
        if (Component[lifecycle] || ((_a = Component.prototype) === null || _a === void 0 ? void 0 : _a[lifecycle]) || Component[lifecycle.replace(/^on/, "enable")]) {
            pageObj[lifecycle] = function(...args) {
                var _a2;
                const target = (_a2 = args[0]) === null || _a2 === void 0 ? void 0 : _a2.target;
                if (target === null || target === void 0 ? void 0 : target.id) {
                    const id2 = target.id;
                    const element = document$1.getElementById(id2);
                    if (element) {
                        target.dataset = element.dataset;
                    }
                }
                return safeExecute(this.$taroPath, lifecycle, ...args);
            };
        }
    });
    pageObj.eh = eventHandler;
    if (!isUndefined(data)) {
        pageObj.data = data;
    }
    hooks.call("modifyPageObject", pageObj);
    return pageObj;
}
function createH5NativeComponentConfig(Component, react, reactdom) {
    reactMeta.R = react;
    h = react.createElement;
    ReactDOM = reactdom;
    setReconciler(ReactDOM);
    return Component;
}
function createNativeComponentConfig(Component, react, reactdom, componentConfig) {
    var _a, _b;
    reactMeta.R = react;
    h = react.createElement;
    ReactDOM = reactdom;
    setReconciler(ReactDOM);
    const { isNewBlended } = componentConfig;
    const componentObj = {
        options: componentConfig,
        properties: {
            props: {
                type: null,
                value: null,
                observer (_newVal, oldVal) {
                    var _a2;
                    oldVal && ((_a2 = this.component) === null || _a2 === void 0 ? void 0 : _a2.forceUpdate());
                }
            }
        },
        created () {
            const app = isNewBlended ? nativeComponentApp : Current.app;
            if (!app) {
                initNativeComponentEntry({
                    R: react,
                    ReactDOM,
                    isDefaultEntryDom: !isNewBlended
                });
            }
        },
        attached () {
            const compId = this.compId = getNativeCompId();
            setCurrent(compId);
            this.config = componentConfig;
            const app = isNewBlended ? nativeComponentApp : Current.app;
            app.mount(Component, compId, ()=>this, ()=>{
                const instance = getPageInstance(compId);
                if (instance && instance.node) {
                    const el = document$1.getElementById(instance.node.uid);
                    if (el) {
                        el.ctx = this;
                    }
                }
            });
        },
        ready () {
            safeExecute(this.compId, "onReady");
        },
        detached () {
            resetCurrent();
            const app = isNewBlended ? nativeComponentApp : Current.app;
            app.unmount(this.compId);
        },
        pageLifetimes: {
            show (options) {
                safeExecute(this.compId, "onShow", options);
            },
            hide () {
                safeExecute(this.compId, "onHide");
            }
        },
        methods: {
            eh: eventHandler,
            onLoad (options) {
                safeExecute(this.compId, "onLoad", options);
            },
            onUnload () {
                safeExecute(this.compId, "onUnload");
            }
        }
    };
    function resetCurrent() {
        Current.page = null;
        Current.router = null;
    }
    if (Component.onShareAppMessage || ((_a = Component.prototype) === null || _a === void 0 ? void 0 : _a.onShareAppMessage) || Component.enableShareAppMessage) {
        componentObj.methods.onShareAppMessage = function(options) {
            const target = options === null || options === void 0 ? void 0 : options.target;
            if (target) {
                const id = target.id;
                const element = document$1.getElementById(id);
                if (element) {
                    target.dataset = element.dataset;
                }
            }
            return safeExecute(this.compId, "onShareAppMessage", options);
        };
    }
    if (Component.onShareTimeline || ((_b = Component.prototype) === null || _b === void 0 ? void 0 : _b.onShareTimeline) || Component.enableShareTimeline) {
        componentObj.methods.onShareTimeline = function() {
            return safeExecute(this.compId, "onShareTimeline");
        };
    }
    return componentObj;
}
function setCurrent(compId) {
    if (!getCurrentPages || typeof getCurrentPages !== "function") return;
    const pages = getCurrentPages();
    const currentPage = pages[pages.length - 1];
    if (Current.page === currentPage) return;
    Current.page = currentPage;
    const route = currentPage.route || currentPage.__route__;
    const router = {
        params: currentPage.options || {},
        path: addLeadingSlash(route),
        $taroPath: compId,
        onReady: "",
        onHide: "",
        onShow: ""
    };
    Current.router = router;
    if (!currentPage.options) {
        Object.defineProperty(currentPage, "options", {
            enumerable: true,
            configurable: true,
            get () {
                return this._optionsValue;
            },
            set (value) {
                router.params = value;
                this._optionsValue = value;
            }
        });
    }
}
hooks.tap("initNativeApi", function(taro) {
    for(const hook in taroHooks){
        taro[hook] = taroHooks[hook];
    }
});
if (false) {
    const options = null.options;
    const oldVNodeHook = options.vnode;
    const oldDiffedHook = options.diffed;
    options.vnode = (vnode)=>{
        const { type, props } = vnode;
        let normalizedProps = props;
        if (typeof type === "string") {
            normalizedProps = {};
            for(let i in props){
                const value = props[i];
                if (/^on/.test(i)) {
                    i = i.toLowerCase();
                }
                if (type === "map" && i === "onregionchange") {
                    normalizedProps.onbegin = value;
                    normalizedProps.onend = value;
                    continue;
                }
                normalizedProps[i] = value;
            }
            vnode.props = normalizedProps;
        }
        if (oldVNodeHook) oldVNodeHook(vnode);
    };
    options.diffed = function(newVNode) {
        var _a;
        const domProp = Object.keys(newVNode).find((k)=>{
            var _a2;
            return (_a2 = newVNode[k]) === null || _a2 === void 0 ? void 0 : _a2.setAttribute;
        });
        const dom = domProp ? newVNode[domProp] : null;
        const newVNodeProps = newVNode.props;
        if (dom) {
            for(const propName in newVNodeProps){
                const propValue = newVNodeProps[propName];
                if (propValue === false && ((_a = dom.props) === null || _a === void 0 ? void 0 : _a[propName]) === void 0) {
                    dom.setAttribute(propName, propValue);
                }
            }
        }
        if (oldDiffedHook) oldDiffedHook(newVNode);
    };
    hooks.tap("modifyMpEvent", (e)=>{
        const type = e.type;
        if (type === "tap") {
            e.type = "click";
        } else if (type === "focus") {
            e.type = "focusin";
        } else if (type === "blur") {
            e.type = "focusout";
        }
    });
}
export { connectReactPage, createH5NativeComponentConfig, createNativeComponentConfig, createNativePageConfig, createReactApp, setReconciler, useAddToFavorites, useDidHide, useDidShow, useError, useLaunch, useLoad, useOptionMenuClick, usePageNotFound, usePageScroll, usePullDownRefresh, usePullIntercept, useReachBottom, useReady, useResize, useRouter, useSaveExitState, useScope, useShareAppMessage, useShareTimeline, useTabItemTap, useTitleClick, useUnhandledRejection, useUnload };
