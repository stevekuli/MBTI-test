"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeGeometry = void 0;
const react_native_1 = require("react-native");
const computeGeometry = (contentSize, placement, fromRect, displayArea, arrowSize) => {
    const effectiveArrowSize = getArrowSize(arrowSize, placement);
    switch (placement) {
        case 'top':
            return computeTopGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);
        case 'bottom':
            return computeBottomGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);
        case 'start':
            return computeStartGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);
        case 'end':
            return computeEndGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);
        default:
            return computeAutoGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);
    }
};
exports.computeGeometry = computeGeometry;
const getArrowSize = (size, placement) => {
    if (placement === 'start' || placement === 'end') {
        return { width: size.height, height: size.width };
    }
    return size;
};
const computeTopGeometry = (displayArea, fromRect, contentSize, arrowSize) => {
    const origin = {
        x: Math.min(displayArea.x + displayArea.width - contentSize.width, Math.max(displayArea.x, fromRect.x +
            (fromRect.width - contentSize.width) / 2 -
            (react_native_1.I18nManager.isRTL ? fromRect.width : 0))),
        y: fromRect.y - contentSize.height - arrowSize.height,
    };
    const anchor = {
        x: fromRect.x + (fromRect.width / 2) * (react_native_1.I18nManager.isRTL ? -1 : 1),
        y: fromRect.y,
    };
    return { origin, anchor, placement: 'top' };
};
const computeBottomGeometry = (displayArea, fromRect, contentSize, arrowSize) => {
    const origin = {
        x: Math.min(displayArea.x + displayArea.width - contentSize.width, Math.max(displayArea.x, fromRect.x +
            (fromRect.width - contentSize.width) / 2 -
            (react_native_1.I18nManager.isRTL ? fromRect.width : 0))),
        y: fromRect.y + fromRect.height + arrowSize.height,
    };
    const anchor = {
        x: fromRect.x + (fromRect.width / 2) * (react_native_1.I18nManager.isRTL ? -1 : 1),
        y: fromRect.y + fromRect.height,
    };
    return { origin, anchor, placement: 'bottom' };
};
const computeStartGeometry = (displayArea, fromRect, contentSize, arrowSize) => {
    const origin = {
        x: fromRect.x -
            contentSize.width -
            arrowSize.width -
            (react_native_1.I18nManager.isRTL ? fromRect.width : 0),
        y: Math.min(displayArea.y + displayArea.height - contentSize.height, Math.max(displayArea.y, fromRect.y + fromRect.height - contentSize.height)),
    };
    const anchor = {
        x: fromRect.x - (react_native_1.I18nManager.isRTL ? fromRect.width : 0),
        y: fromRect.y + fromRect.height - contentSize.height / 2,
    };
    return { origin, anchor, placement: 'start' };
};
const computeEndGeometry = (displayArea, fromRect, contentSize, arrowSize) => {
    const origin = {
        x: fromRect.x +
            fromRect.width +
            arrowSize.width -
            (react_native_1.I18nManager.isRTL ? fromRect.width : 0),
        y: Math.min(displayArea.y + displayArea.height - contentSize.height, Math.max(displayArea.y, fromRect.y + fromRect.height - contentSize.height)),
    };
    const anchor = {
        x: fromRect.x + (react_native_1.I18nManager.isRTL ? 0 : fromRect.width),
        y: fromRect.y + fromRect.height - contentSize.height / 2,
    };
    return { origin, anchor, placement: 'end' };
};
const computeAutoGeometry = (displayArea, fromRect, contentSize, arrowSize) => {
    let geom = null;
    const placements = ['start', 'end', 'top', 'bottom'];
    for (let i = 0; i < 4; i += 1) {
        const placement = placements[i];
        geom = (0, exports.computeGeometry)(contentSize, placement, fromRect, displayArea, arrowSize);
        const { origin } = geom;
        if (origin.x >= displayArea.x &&
            origin.x <= displayArea.x + displayArea.width - contentSize.width &&
            origin.y >= displayArea.y &&
            origin.y <= displayArea.y + displayArea.height - contentSize.height) {
            break;
        }
    }
    return geom;
};
//# sourceMappingURL=PopoverGeometry.js.map